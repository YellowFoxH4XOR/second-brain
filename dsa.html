<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Ultimate DSA Learning Guide</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #818cf8;
            --secondary: #8b5cf6;
            --accent: #ec4899;
            --dark: #0f172a;
            --dark-light: #1e293b;
            --gray: #64748b;
            --gray-light: #cbd5e1;
            --gray-lighter: #f1f5f9;
            --success: #10b981;
            --shadow: rgba(99, 102, 241, 0.15);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            line-height: 1.6;
            color: var(--dark);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 50px;
            padding: 60px 20px 40px;
            animation: slideDown 0.8s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .header h1 {
            font-size: 3.5rem;
            font-weight: 800;
            margin-bottom: 15px;
            text-shadow: 0 4px 20px rgba(0,0,0,0.2);
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, #ffffff 0%, #e0e7ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.25rem;
            opacity: 0.95;
            font-weight: 400;
            letter-spacing: 0.01em;
        }

        .search-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 35px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            border: 1px solid rgba(255, 255, 255, 0.5);
            animation: fadeInUp 0.8s ease-out 0.2s both;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .search-box {
            width: 100%;
            padding: 18px 24px;
            border: 2px solid var(--gray-lighter);
            border-radius: 14px;
            font-size: 1.05rem;
            font-family: 'Inter', sans-serif;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: white;
        }

        .search-box:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 4px var(--shadow), 0 8px 20px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .search-box::placeholder {
            color: var(--gray);
        }

        .nav-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 40px;
            justify-content: center;
            animation: fadeInUp 0.8s ease-out 0.3s both;
        }

        .nav-tab {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 14px 28px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            position: relative;
            overflow: hidden;
        }

        .nav-tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .nav-tab:hover::before {
            left: 100%;
        }

        .nav-tab:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .nav-tab.active {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border-color: transparent;
            box-shadow: 0 8px 30px var(--shadow);
        }

        .topic-section {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 45px;
            margin-bottom: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.12);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .topic-section.active {
            display: block;
            animation: fadeInScale 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes fadeInScale {
            from { 
                opacity: 0; 
                transform: scale(0.95) translateY(20px);
            }
            to { 
                opacity: 1; 
                transform: scale(1) translateY(0);
            }
        }

        .topic-header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 30px;
            position: relative;
        }

        .topic-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 2px;
        }

        .topic-title {
            font-size: 3rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary), var(--secondary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            letter-spacing: -0.02em;
        }

        .topic-description {
            font-size: 1.15rem;
            color: var(--gray);
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.7;
            font-weight: 400;
        }

        .subtopics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }

        .subtopic-card {
            background: white;
            border-radius: 16px;
            padding: 30px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            border: 1px solid var(--gray-lighter);
            box-shadow: 0 4px 20px rgba(0,0,0,0.04);
        }

        .subtopic-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--secondary), var(--accent));
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .subtopic-card:hover::before {
            transform: scaleX(1);
        }

        .subtopic-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.12);
            border-color: var(--primary-light);
        }

        .subtopic-title {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--dark);
            margin-bottom: 15px;
            letter-spacing: -0.01em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .subtopic-title::before {
            content: '‚óè';
            color: var(--primary);
            font-size: 0.6em;
        }

        .subtopic-description {
            color: var(--gray);
            margin-bottom: 24px;
            line-height: 1.7;
            font-size: 0.98rem;
        }

        .prompt-box {
            background: linear-gradient(135deg, var(--dark) 0%, var(--dark-light) 100%);
            color: #e2e8f0;
            padding: 24px;
            border-radius: 12px;
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            position: relative;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
        }

        .prompt-box:hover {
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
            transform: scale(1.01);
            box-shadow: 0 8px 24px rgba(0,0,0,0.2), inset 0 1px 2px rgba(0,0,0,0.2);
        }

        .prompt-box::before {
            content: 'üí°';
            position: absolute;
            top: 14px;
            right: 18px;
            font-size: 1.3rem;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        .copy-btn {
            position: absolute;
            top: 14px;
            right: 50px;
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 14px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }

        .prompt-box:hover .copy-btn {
            opacity: 1;
        }

        .copy-btn:hover {
            background: var(--primary-dark);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }

        .copy-btn:active {
            transform: scale(0.95);
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 50px;
            margin-top: 60px;
            flex-wrap: wrap;
            animation: fadeInUp 0.8s ease-out 0.4s both;
        }

        .stat-item {
            text-align: center;
            color: white;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 30px 50px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .stat-item:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: 800;
            display: block;
            background: linear-gradient(135deg, #ffffff 0%, #e0e7ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            font-size: 1rem;
            opacity: 0.9;
            font-weight: 500;
            margin-top: 5px;
        }

        .footer {
            text-align: center;
            color: white;
            margin-top: 60px;
            padding: 40px 0;
            opacity: 0.85;
            font-weight: 400;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            border: 2px solid transparent;
            background-clip: padding-box;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
            background-clip: padding-box;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header p {
                font-size: 1rem;
            }
            
            .topic-title {
                font-size: 2.2rem;
            }
            
            .subtopics-grid {
                grid-template-columns: 1fr;
            }
            
            .nav-tabs {
                flex-direction: column;
                align-items: stretch;
                padding: 0 20px;
            }
            
            .nav-tab {
                width: 100%;
            }

            .topic-section {
                padding: 25px;
            }

            .stats {
                gap: 25px;
            }

            .stat-item {
                padding: 20px 35px;
            }
        }

        .highlight {
            background: linear-gradient(120deg, #a8edea 0%, #fed6e3 100%);
            padding: 2px 8px;
            border-radius: 6px;
            font-weight: 600;
        }

        /* Loading animation for smooth transitions */
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.8;
            }
        }

        .loading {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ The Ultimate DSA Learning Guide</h1>
            <p>Master Data Structures and Algorithms with AI-Powered Learning Prompts</p>
        </div>

        <div class="search-container">
            <input type="text" class="search-box" id="searchBox" placeholder="üîç Search topics, subtopics, or keywords...">
        </div>

        <div class="nav-tabs" id="navTabs">
            <!-- Navigation tabs will be populated by JavaScript -->
        </div>

        <div id="topicSections">
            <!-- Topic sections will be populated by JavaScript -->
        </div>

        <div class="stats">
            <div class="stat-item">
                <span class="stat-number">22</span>
                <span class="stat-label">Main Topics</span>
            </div>
            <div class="stat-item">
                <span class="stat-number">150+</span>
                <span class="stat-label">Subtopics</span>
            </div>
            <div class="stat-item">
                <span class="stat-number">200+</span>
                <span class="stat-label">LLM Prompts</span>
            </div>
        </div>

        <div class="footer">
            <p>¬© 2024 The Ultimate DSA Learning Guide | Master algorithms with AI assistance</p>
        </div>
    </div>

    <script>
        const dsaData = {
            "Arrays": {
                description: "Fundamental linear data structure for storing elements in contiguous memory locations.",
                subtopics: [
                    {
                        title: "1D and 2D Arrays",
                        description: "Understanding single and multi-dimensional array structures and their memory layout.",
                        prompt: "I want to deeply understand 1D and 2D arrays. Please:\n1. Explain how arrays are stored in memory (contiguous memory, indexing)\n2. Show me the difference between row-major and column-major ordering for 2D arrays\n3. Provide clear code examples in Python and C++ showing initialization and access patterns\n4. Include visual diagrams or ASCII art to illustrate memory layout\n5. Explain time complexity for access, search, insert operations\n6. Give me 2-3 practice problems with detailed solutions\nUse a teaching approach with examples building from simple to complex."
                    },
                    {
                        title: "Array Operations",
                        description: "Core operations: insertion, deletion, traversal, searching, and updating elements.",
                        prompt: "I need a comprehensive lesson on array operations. Please:\n1. For each operation (insert, delete, traverse, search, update), explain:\n   - How it works conceptually\n   - Step-by-step algorithm\n   - Time and space complexity with explanation\n   - Code implementation in Python\n2. Show edge cases for each operation (empty array, single element, full array)\n3. Compare: insert at beginning vs middle vs end\n4. Provide 3 practice problems that combine multiple operations\n5. Include common pitfalls and how to avoid them\nTeach this as if I'm learning for the first time."
                    },
                    {
                        title: "Two Pointer Technique",
                        description: "Efficient algorithm pattern using two pointers to solve array problems.",
                        prompt: "Teach me the two pointer technique from fundamentals to mastery:\n1. Core concept: Why do we use two pointers? What problem does it solve?\n2. Pattern 1: Opposite direction pointers (left/right)\n   - When to use\n   - Example problem with detailed walkthrough\n3. Pattern 2: Same direction pointers (fast/slow)\n   - When to use\n   - Example problem with detailed walkthrough\n4. Pattern 3: Sliding window with two pointers\n5. Show me 5 classic problems with complete solutions:\n   - Two Sum (sorted array)\n   - Container with Most Water\n   - Remove Duplicates\n   - Three Sum\n   - Trapping Rain Water\n6. For each problem: intuition ‚Üí approach ‚Üí code ‚Üí complexity analysis\nBuild my understanding progressively."
                    },
                    {
                        title: "Sliding Window Technique",
                        description: "Optimized approach for solving subarray and substring problems.",
                        prompt: "I want to master the sliding window technique. Please teach me:\n1. What is the sliding window pattern and why is it powerful?\n2. Fixed-size windows:\n   - Concept and template code\n   - Example: Maximum sum of k consecutive elements\n   - Step-by-step visualization\n3. Variable-size windows:\n   - Concept and template code\n   - Example: Longest substring without repeating characters\n   - When to expand vs shrink the window\n4. Common variations:\n   - Minimum window substring\n   - Maximum window with constraint\n5. Provide 5 practice problems with solutions:\n   - Beginner (2 problems)\n   - Intermediate (2 problems)\n   - Advanced (1 problem)\n6. Include the problem-solving pattern I should follow\nUse clear examples and build from basic to advanced."
                    },
                    {
                        title: "Prefix Sums and Difference Arrays",
                        description: "Preprocessing techniques for efficient range queries and updates.",
                        prompt: "Explain prefix sums and difference arrays as a complete lesson:\n1. Prefix Sum Array:\n   - What problem does it solve?\n   - How to build it (with visual example)\n   - How to query range sum in O(1)\n   - Code implementation with detailed comments\n2. 2D Prefix Sum:\n   - Extension to matrices\n   - How to query sub-rectangle sum\n   - Implementation with example\n3. Difference Array:\n   - What problem does it solve?\n   - How range updates become O(1)\n   - Building and reconstructing the array\n   - Code implementation\n4. Compare: When to use prefix sum vs difference array\n5. Provide 4 practice problems:\n   - 2 on prefix sums\n   - 2 on difference arrays\n   - Include LeetCode-style problems with solutions\n6. Show me the time complexity improvement with examples\nMake sure I understand the intuition behind each technique."
                    },
                    {
                        title: "Array Applications",
                        description: "Real-world applications in sorting, searching, and subarray problems.",
                        prompt: "Show me how arrays are used in real-world scenarios:\n1. Practical applications:\n   - Database indexing\n   - Image processing (2D arrays)\n   - Time-series data analysis\n   - Game development (grid-based games)\n2. Common algorithm patterns:\n   - Kadane's algorithm for maximum subarray\n   - Dutch national flag problem\n   - Merge intervals\n   - Product of array except self\n3. For each pattern:\n   - Real-world use case\n   - Problem statement\n   - Intuitive explanation\n   - Code with line-by-line comments\n   - Time/space complexity\n4. Give me 3 medium-level problems that appear in interviews\n5. Show optimization techniques (space-time tradeoffs)\nHelp me see the bigger picture of how arrays solve real problems."
                    }
                ]
            },
            "Strings": {
                description: "Sequence of characters with specialized algorithms for text processing and pattern matching.",
                subtopics: [
                    {
                        title: "String Operations",
                        description: "Basic string manipulation: concatenation, substring, reversal, comparison.",
                        prompt: "I want to master fundamental string operations. Please provide:\n1. Memory representation of strings (immutable vs mutable in different languages)\n2. Core operations with complexity analysis:\n   - Concatenation (+ vs join, when to use which)\n   - Substring extraction\n   - String reversal (multiple methods)\n   - String comparison (lexicographic, case-sensitive/insensitive)\n3. Common string manipulation patterns:\n   - Removing characters\n   - Character frequency counting\n   - Anagram checking\n4. Implement each in Python with explanation\n5. Show 3 interview problems that test these basics\n6. Common mistakes and optimization tips\nMake sure I understand why strings are often immutable and how that affects operations."
                    },
                    {
                        title: "Pattern Matching Algorithms",
                        description: "Advanced algorithms: Naive, KMP, Z-algorithm, Rabin-Karp for efficient pattern searching.",
                        prompt: "Teach me pattern matching algorithms step-by-step:\n1. Naive Algorithm:\n   - How it works with visualization\n   - Time complexity: why O(m*n)?\n   - Code implementation\n2. KMP Algorithm:\n   - The intuition: what makes KMP efficient?\n   - Building the LPS (Longest Prefix Suffix) array - explain with example\n   - Complete algorithm walkthrough with 'ABABCABAB' example\n   - Implementation with detailed comments\n   - Why O(m+n)?\n3. Rabin-Karp Algorithm:\n   - Rolling hash concept\n   - How to handle hash collisions\n   - Implementation\n4. Z-Algorithm:\n   - What is the Z-array?\n   - Construction and usage\n   - Implementation\n5. Compare all four: when to use each?\n6. Give me 3 practice problems using these algorithms\nUse visual examples and build intuition before code."
                    },
                    {
                        title: "String Hashing",
                        description: "Using hash functions for fast string comparison and pattern matching.",
                        prompt: "Explain string hashing comprehensively:\n1. Why hash strings? What problems does it solve?\n2. Polynomial Hash Function:\n   - Formula: hash = (s[0]*p^0 + s[1]*p^1 + ... + s[n-1]*p^(n-1)) mod m\n   - Choosing p and m values\n   - Implementation in Python\n3. Rolling Hash:\n   - How to compute hash of next substring in O(1)\n   - Add/remove character from hash\n   - Use case: Rabin-Karp\n4. Collision handling:\n   - Double hashing technique\n   - Choosing good hash functions\n5. Applications:\n   - String matching\n   - Finding duplicate substrings\n   - Longest common substring\n6. Provide 3 problems with complete solutions:\n   - Beginner: Check if strings are anagrams\n   - Intermediate: Find all anagrams in a string\n   - Advanced: Longest duplicate substring\nShow me the probability calculations for collisions."
                    },
                    {
                        title: "Palindrome Problems",
                        description: "Algorithms for detecting and working with palindromic strings.",
                        prompt: "Teach me everything about palindrome algorithms:\n1. Basic palindrome check:\n   - Two pointer approach\n   - Recursive approach\n   - Time/space complexity\n2. Expand Around Center technique:\n   - Concept with visualization\n   - Finding longest palindromic substring\n   - Handling even and odd length palindromes\n3. Dynamic Programming approach:\n   - 2D DP table for palindrome checking\n   - Filling the table step-by-step\n   - Finding longest palindromic substring using DP\n4. Manacher's Algorithm:\n   - What makes it O(n)?\n   - How it works (simplified explanation)\n   - When to use it\n5. Common palindrome problems:\n   - Valid palindrome\n   - Longest palindromic substring\n   - Palindromic substrings count\n   - Shortest palindrome\n   - Palindrome partitioning\n6. For each problem: provide intuition, approach, code, and complexity\nUse clear examples like 'babad', 'racecar' to illustrate."
                    },
                    {
                        title: "Trie (Prefix Tree)",
                        description: "Tree data structure for efficient string storage and prefix-based operations.",
                        prompt: "I want to deeply understand Tries. Please explain:\n1. What is a Trie and why do we need it?\n   - Problems where Trie excels over other data structures\n2. Trie structure:\n   - Node design (children, isEnd flag)\n   - Visual representation with example words: ['cat', 'car', 'card', 'care', 'careful']\n3. Core operations with implementation:\n   - Insert: step-by-step for 'apple'\n   - Search: complete vs prefix search\n   - Delete: handling edge cases\n   - Each with code and complexity analysis\n4. Advanced Trie operations:\n   - Finding all words with given prefix\n   - Autocomplete implementation\n   - Spell checker basics\n5. Space optimization:\n   - Compressed Trie (Radix Tree)\n   - When to use what\n6. Practice problems:\n   - Implement Trie (LeetCode #208)\n   - Word Search II\n   - Design Add and Search Words Data Structure\n   - Maximum XOR of Two Numbers (using bit Trie)\nProvide complete class implementation with all methods."
                    },
                    {
                        title: "Suffix Arrays and Suffix Trees",
                        description: "Advanced data structures for efficient suffix-based string operations.",
                        prompt: "Teach me Suffix Arrays and Suffix Trees (advanced topic):\n1. Suffix Array:\n   - What is it? Array of all suffixes sorted lexicographically\n   - Example with string 'banana' showing all suffixes\n   - Construction algorithms:\n     * Naive O(n¬≤ log n) approach\n     * Better approaches (overview)\n   - LCP (Longest Common Prefix) array\n   - Applications: pattern searching, finding longest repeated substring\n2. Suffix Tree:\n   - What is it and how is it different from suffix array?\n   - Structure visualization\n   - Construction overview (Ukkonen's algorithm - high level)\n   - Space and time complexity\n3. Applications with examples:\n   - Finding all occurrences of pattern\n   - Longest repeated substring\n   - Longest common substring\n   - Longest palindromic substring\n4. When to use suffix array vs suffix tree vs other approaches?\n5. Provide 2 practice problems:\n   - One using suffix array\n   - One comparing different approaches\nFocus on intuition and use cases rather than implementation details."
                    }
                ]
            },
            "Linked Lists": {
                description: "Dynamic data structure where elements are stored in nodes with pointers to the next element.",
                subtopics: [
                    {
                        title: "Types of Linked Lists",
                        description: "Singly, doubly, and circular linked lists with their characteristics.",
                        prompt: "I want to master linked list types. Please teach me:\n1. Singly Linked List:\n   - Node structure (data + next pointer)\n   - Visual diagram with example: 1 ‚Üí 2 ‚Üí 3 ‚Üí NULL\n   - Implementation in Python (Node class + LinkedList class)\n   - Time/space complexity for operations\n2. Doubly Linked List:\n   - Node structure (prev + data + next)\n   - Advantages over singly linked list\n   - Complete implementation\n   - Operations: insert, delete (how prev pointer helps)\n3. Circular Linked List:\n   - Structure (last node points to first)\n   - Use cases (round-robin scheduling)\n   - Implementation differences\n4. Comparison table: when to use each type\n5. Memory visualization showing how nodes are stored\n6. Give me 3 problems, one for each type\nInclude edge cases like empty list, single node."
                    },
                    {
                        title: "Linked List Operations",
                        description: "Core operations: insertion, deletion, traversal, and reversal.",
                        prompt: "Teach me linked list operations comprehensively:\n1. Traversal:\n   - Iterative approach with code\n   - Recursive approach with code\n   - Time/space complexity\n2. Insertion (with visuals):\n   - At beginning (O(1))\n   - At end (O(n) vs O(1) with tail pointer)\n   - At position k\n   - After a given node\n   - Each with step-by-step pointer manipulation\n3. Deletion:\n   - Delete first node\n   - Delete last node\n   - Delete node with value x\n   - Delete node at position k\n   - Handle edge cases (node not found, single node, etc.)\n4. Reversal:\n   - Iterative method (explain pointer manipulation step-by-step)\n   - Recursive method\n   - Visualize with example: 1‚Üí2‚Üí3‚Üí4 becomes 4‚Üí3‚Üí2‚Üí1\n5. Provide complete LinkedList class with all operations\n6. Give me 5 practice problems using these operations\nUse diagrams to show pointer changes."
                    },
                    {
                        title: "Cycle Detection (Floyd's Algorithm)",
                        description: "Detecting and removing cycles in linked lists using Floyd's cycle detection.",
                        prompt: "Explain Floyd's Cycle Detection (Tortoise and Hare) in depth:\n1. The problem: What is a cycle in a linked list?\n   - Visual example with a cycle\n2. Floyd's Algorithm intuition:\n   - Why use slow and fast pointers?\n   - Mathematical proof (why they must meet if cycle exists)\n   - Step-by-step walkthrough with diagram\n3. Detection phase:\n   - Complete code implementation\n   - Why this works: explain with example\n4. Finding cycle start:\n   - Why reset one pointer to head?\n   - Mathematical reasoning\n   - Code implementation\n5. Finding cycle length\n6. Removing the cycle:\n   - Method to break the cycle\n   - Code implementation\n7. Time: O(n), Space: O(1) - explain why\n8. Give me 3 related problems:\n   - Detect cycle\n   - Find cycle start\n   - Remove cycle\nUse visual animations in explanation."
                    },
                    {
                        title: "Merging and Intersection",
                        description: "Algorithms for merging sorted lists and finding intersections.",
                        prompt: "Teach me merging and intersection algorithms:\n1. Merge Two Sorted Lists:\n   - Problem statement with example\n   - Approach: dummy node technique\n   - Step-by-step walkthrough: merge [1,2,4] and [1,3,4]\n   - Iterative implementation\n   - Recursive implementation\n   - Time: O(m+n), Space complexity analysis\n2. Merge K Sorted Lists:\n   - Multiple approaches:\n     a) Merge two at a time\n     b) Using min-heap\n     c) Divide and conquer\n   - Compare time complexities\n   - Implement heap-based solution\n3. Intersection of Two Linked Lists:\n   - What does intersection mean?\n   - Visual example showing Y-shaped lists\n   - Approach 1: Using hash set\n   - Approach 2: Two pointers (elegant solution)\n   - Why the two-pointer method works (mathematical proof)\n   - Implementation\n4. Provide 3 practice problems\nShow detailed diagrams for intersection."
                    },
                    {
                        title: "Advanced Linked List Problems",
                        description: "Complex problems like reversing in groups, detecting loops, and palindrome detection.",
                        prompt: "Teach me advanced linked list problems:\n1. Reverse Nodes in K-Group:\n   - Problem: reverse every k nodes\n   - Example: 1‚Üí2‚Üí3‚Üí4‚Üí5, k=3 becomes 3‚Üí2‚Üí1‚Üí4‚Üí5\n   - Algorithm breakdown\n   - Implementation with helper function\n2. Palindrome Linked List:\n   - Multiple approaches:\n     a) Using extra space (array/stack)\n     b) Space-optimized (reverse second half)\n   - Step-by-step: find middle, reverse, compare\n   - Complete implementation\n3. Reorder List:\n   - Problem: L0‚ÜíL1‚Üí...‚ÜíLn becomes L0‚ÜíLn‚ÜíL1‚ÜíLn-1...\n   - Three-step approach\n   - Visual walkthrough\n4. Copy List with Random Pointer:\n   - Problem explanation\n   - Hash map approach\n   - O(1) space approach (interweaving nodes)\n5. Add Two Numbers (lists represent numbers in reverse):\n   - Handle carry\n   - Different lengths\n   - Implementation\n6. Provide detailed solution for each problem\nFocus on problem-solving patterns."
                    },
                    {
                        title: "Applications",
                        description: "Real-world applications in memory management, LRU cache, and undo operations.",
                        prompt: "Show me real-world linked list applications:\n1. LRU Cache Implementation:\n   - What is LRU (Least Recently Used)?\n   - Why use linked list + hash map?\n   - Design with doubly linked list\n   - Operations: get() and put()\n   - Step-by-step example with cache size 3\n   - Complete implementation with both classes\n   - Time complexity: O(1) for both operations\n2. Browser History (Forward/Back buttons):\n   - Using doubly linked list\n   - Implementation\n3. Undo/Redo in Text Editors:\n   - Stack-based approach using linked list\n   - Implementation sketch\n4. Memory Management:\n   - Free list in malloc/free\n   - How OS uses linked lists\n5. Music Playlist:\n   - Circular linked list for continuous play\n6. Polynomial Representation:\n   - Sparse polynomials using linked lists\n7. Provide 2 complete implementations:\n   - LRU Cache (detailed)\n   - Browser History\nShow me how these are better than array-based solutions."
                    }
                ]
            },
            "Stacks": {
                description: "LIFO (Last In, First Out) data structure for managing elements with push and pop operations.",
                subtopics: [
                    {
                        title: "Stack Operations",
                        description: "Basic operations: push, pop, peek, and isEmpty with their implementations.",
                        prompt: "Teach me stack fundamentals:\n1. What is a Stack?\n   - LIFO principle with real-world analogy (plate stack)\n   - Visual representation\n2. Core Operations:\n   - push(item): add to top\n   - pop(): remove from top\n   - peek()/top(): view top element\n   - isEmpty(): check if empty\n   - size(): get count\n3. Array-based Implementation:\n   - Using dynamic array\n   - Complete Python class\n   - Handle overflow (dynamic resizing)\n   - Time complexity for each operation\n4. Linked List Implementation:\n   - Node structure\n   - Complete implementation\n   - Why top is at head (O(1) operations)\n   - Memory comparison with array\n5. When to use which implementation?\n6. Give me 3 basic problems:\n   - Implement stack\n   - Min stack (get minimum in O(1))\n   - Stack using queues\nShow complete working code for both implementations."
                    },
                    {
                        title: "Stack Implementation",
                        description: "Implementing stacks using arrays and linked lists with pros and cons.",
                        prompt: "Deep dive into stack implementations:\n1. Array-based Stack:\n   - Fixed size vs dynamic\n   - Implementation with capacity handling\n   - Push with resize logic\n   - Amortized analysis of push operation\n   - Space efficiency\n2. Linked List Stack:\n   - Node class design\n   - Stack class with head pointer\n   - Complete implementation\n   - No size limit benefit\n3. Comparison Table:\n   - Memory overhead\n   - Cache performance\n   - When array is better\n   - When linked list is better\n4. Special Stack Implementations:\n   - Stack with getMin() in O(1)\n   - Stack with getMiddle() in O(1)\n   - Implementation of each\n5. Built-in Stack Usage:\n   - Python: list\n   - Java: Stack vs Deque\n   - C++: std::stack\n6. Provide complete implementations with all edge case handling"
                    },
                    {
                        title: "Expression Evaluation",
                        description: "Using stacks to evaluate infix, prefix, and postfix expressions.",
                        prompt: "Master expression evaluation with stacks:\n1. Notation Types:\n   - Infix: A + B\n   - Prefix: + A B\n   - Postfix: A B +\n   - Why postfix is computer-friendly\n2. Postfix Evaluation:\n   - Algorithm step-by-step\n   - Example: \"2 3 1 * + 9 -\" = ?\n   - Complete implementation\n   - Handle multi-digit numbers\n3. Infix to Postfix Conversion:\n   - Operator precedence handling\n   - Associativity rules\n   - Algorithm with two stacks\n   - Example: \"A+B*C-D\" conversion\n   - Complete code\n4. Infix to Prefix Conversion:\n   - Reverse approach\n   - Implementation\n5. Calculator Implementation:\n   - Handle +, -, *, /, (, )\n   - Operator precedence\n   - Complete working calculator\n6. Advanced:\n   - Handle unary operators\n   - Function calls\n7. Provide 4 practice problems with solutions"
                    },
                    {
                        title: "Balanced Parentheses",
                        description: "Checking for balanced brackets, parentheses, and other delimiters using stacks.",
                        prompt: "Teach me parentheses matching using stacks:\n1. Valid Parentheses Problem:\n   - Input: \"({[]})\"\n   - Why stack is perfect for this\n   - Algorithm:\n     * Push opening brackets\n     * Pop and match closing brackets\n   - Step-by-step example\n   - Complete implementation\n2. Multiple Bracket Types:\n   - (, {, [\n   - Matching logic\n   - Hash map for pairs\n3. Extended Problems:\n   a) Min additions to make valid:\n      - Count unmatched\n      - Implementation\n   b) Longest valid parentheses:\n      - DP approach\n      - Stack approach (indices)\n      - Detailed solution\n   c) Remove invalid parentheses:\n      - BFS approach\n      - Backtracking approach\n4. Applications:\n   - Syntax checking in compilers\n   - HTML/XML tag matching\n5. Edge cases:\n   - Empty string\n   - Only opening/closing\n   - Interleaved brackets\n6. Give me 5 related problems with complete solutions"
                    },
                    {
                        title: "Monotonic Stack",
                        description: "Specialized stack technique for solving next greater/lesser element problems.",
                        prompt: "Master monotonic stacks:\n1. What is Monotonic Stack?\n   - Maintains elements in increasing/decreasing order\n   - When to use: finding next greater/smaller elements\n2. Next Greater Element:\n   - Problem: for each element, find next greater\n   - Brute force: O(n¬≤)\n   - Monotonic stack approach: O(n)\n   - Algorithm walkthrough with [4,5,2,25]\n   - Why it works (intuition)\n   - Complete implementation\n3. Variations:\n   - Next smaller element\n   - Previous greater element\n   - Previous smaller element\n   - Code for each\n4. Classic Problems:\n   a) Largest Rectangle in Histogram:\n      - Problem explanation\n      - Using monotonic stack\n      - Step-by-step solution\n      - Complete code\n   b) Trapping Rain Water:\n      - Two approaches: DP and stack\n      - Stack-based solution detailed\n      - Implementation\n   c) Maximum Rectangle in Binary Matrix:\n      - Reduce to histogram problem\n      - Solution\n5. Pattern Recognition:\n   - When to use monotonic stack\n   - Template code\n6. Provide 5 practice problems with hints"
                    },
                    {
                        title: "Backtracking Applications",
                        description: "Using stacks for backtracking algorithms and undo operations.",
                        prompt: "Understand stacks in backtracking:\n1. Why Stacks for Backtracking?\n   - Implicit stack in recursion\n   - Explicit stack for iteration\n   - State saving and restoration\n2. Iterative DFS Using Stack:\n   - vs recursive DFS\n   - Implementation for graph/tree\n   - When to use iterative\n3. Path Problems:\n   - All paths from source to destination\n   - Using stack to track current path\n   - Complete implementation\n4. Undo/Redo Implementation:\n   - Two stacks approach\n   - Text editor example\n   - Complete class with operations\n5. Browser History:\n   - Forward and back buttons\n   - Implementation using stacks\n6. Classic Backtracking with Explicit Stack:\n   - Generate parentheses (iterative)\n   - Letter combinations\n   - Subset generation\n7. Comparison:\n   - Recursive vs iterative backtracking\n   - When to use stack explicitly\n8. Provide 3 complete implementations:\n   - Undo/Redo system\n   - Iterative DFS\n   - Path finder"
                    }
                ]
            },
            "Queues": {
                description: "FIFO (First In, First Out) data structure for managing elements in order.",
                subtopics: [
                    {
                        title: "Queue Operations",
                        description: "Basic operations: enqueue, dequeue, front, rear, and isEmpty.",
                        prompt: "Teach me queue fundamentals:\n1. What is a Queue?\n   - FIFO principle with real-world analogy (ticket counter line)\n   - Visual representation\n2. Core Operations:\n   - enqueue(item): add to rear\n   - dequeue(): remove from front\n   - front()/peek(): view front element\n   - isEmpty(): check if empty\n   - size(): get count\n3. Array-based Implementation:\n   - Simple approach (inefficient dequeue)\n   - Problem: wasted space at front\n   - Time complexities\n4. Linked List Implementation:\n   - Front and rear pointers\n   - Complete implementation\n   - Why it's efficient (O(1) for all ops)\n   - Memory considerations\n5. Comparison:\n   - Array vs Linked List\n   - When to use which\n6. Built-in Queue:\n   - Python: collections.deque, queue.Queue\n   - Java: Queue interface, LinkedList\n   - C++: std::queue\n7. Give me 3 practice problems:\n   - Implement queue\n   - Queue using stacks\n   - Reverse a queue\nProvide complete implementations."
                    },
                    {
                        title: "Circular Queues",
                        description: "Efficient queue implementation using circular arrays to avoid space wastage.",
                        prompt: "Master circular queues:\n1. Problem with Simple Array Queue:\n   - Space wastage after dequeues\n   - Example showing the issue\n2. Circular Queue Concept:\n   - Treat array as circular\n   - Use modulo arithmetic\n   - Visual diagram\n3. Implementation Details:\n   - front and rear pointers\n   - How to handle wraparound\n   - Empty vs Full conditions:\n     * Method 1: Use count variable\n     * Method 2: Keep one slot empty\n     * Method 3: Use flag\n   - Which is best and why\n4. Complete Implementation:\n   - Constructor with capacity\n   - enqueue with full check\n   - dequeue with empty check\n   - All operations O(1)\n   - Python code with comments\n5. Edge Cases:\n   - Single element\n   - Queue full\n   - Queue empty\n   - Wraparound scenarios\n6. Applications:\n   - CPU scheduling (Round Robin)\n   - Buffering\n7. Provide 2 complete implementations using different full/empty detection methods"
                    },
                    {
                        title: "Double-ended Queues (Deque)",
                        description: "Queues that allow insertion and deletion from both ends.",
                        prompt: "Learn double-ended queues (Deque):\n1. What is a Deque?\n   - Insert/delete from both ends\n   - More flexible than queue/stack\n   - Visual representation\n2. Operations:\n   - insertFront()\n   - insertRear()\n   - deleteFront()\n   - deleteRear()\n   - getFront()\n   - getRear()\n3. Implementations:\n   a) Circular Array:\n      - Complete implementation\n      - Handle all edge cases\n   b) Doubly Linked List:\n      - Front and rear pointers\n      - Complete code\n   - Compare both approaches\n4. Deque as Stack and Queue:\n   - How deque can simulate both\n   - Code examples\n5. Applications:\n   - Sliding window maximum/minimum\n   - Palindrome checking\n   - Undo-redo with cap\n6. Sliding Window Maximum:\n   - Problem explanation\n   - Using deque to maintain maximum\n   - Step-by-step walkthrough\n   - Complete O(n) solution\n   - Why deque is perfect here\n7. Python's collections.deque:\n   - Built-in methods\n   - Time complexities\n   - When to use\n8. Provide 4 problems solved using deque"
                    },
                    {
                        title: "Priority Queues",
                        description: "Queues where elements are served based on priority rather than arrival order.",
                        prompt: "Master priority queues:\n1. What is a Priority Queue?\n   - Elements have priorities\n   - Highest/lowest priority served first\n   - Real-world examples\n2. Operations:\n   - insert(element, priority)\n   - extractMax()/extractMin()\n   - getMax()/getMin()\n   - changePriority()\n3. Implementation Options:\n   a) Unsorted Array: O(n) extract\n   b) Sorted Array: O(n) insert\n   c) Binary Heap: O(log n) both ‚úì\n   - Why heap is best\n4. Binary Heap Implementation:\n   - Min-heap structure\n   - Complete binary tree in array\n   - Parent-child index formulas\n   - Heapify up and down\n   - Complete PriorityQueue class\n5. Applications:\n   a) Dijkstra's Algorithm:\n      - How PQ is used\n      - Code walkthrough\n   b) Huffman Coding:\n      - Building tree with PQ\n   c) Merge K Sorted Lists:\n      - Using min-heap\n      - Implementation\n   d) Task Scheduling:\n      - By priority/deadline\n6. Python heapq module:\n   - heappush, heappop\n   - heapify\n   - nlargest, nsmallest\n7. Provide 5 problems:\n   - Kth largest element\n   - Top K frequent elements\n   - Merge K sorted lists\n   - Task scheduler\n   - Median from data stream"
                    },
                    {
                        title: "Queue Applications",
                        description: "Applications in BFS traversal, scheduling, and sliding window problems.",
                        prompt: "Explore queue applications:\n1. Breadth-First Search (BFS):\n   - Why queue is essential for BFS\n   - Graph BFS implementation\n   - Tree level-order traversal\n   - Finding shortest path in unweighted graph\n   - Complete code examples\n2. Level Order Tree Traversal:\n   - Standard level order\n   - Level order with level separation\n   - Zigzag level order\n   - Each with implementation\n3. Shortest Path in Maze/Grid:\n   - BFS for grid\n   - 4-directional movement\n   - Complete implementation\n4. Rotting Oranges Problem:\n   - Multi-source BFS\n   - Step-by-step solution\n   - Code implementation\n5. CPU Scheduling:\n   - Round Robin algorithm\n   - Using circular queue\n   - Implementation\n6. Request Handling:\n   - Web server queue\n   - Print queue\n   - Concept and pseudocode\n7. Sliding Window with Queue:\n   - Fixed-size window problems\n   - Using deque for min/max\n8. Generate Binary Numbers:\n   - 1 to n using queue\n   - Elegant solution\n9. Provide 5 BFS problems:\n   - Binary tree level order\n   - Word ladder\n   - 01 Matrix\n   - Walls and gates\n   - Shortest path binary matrix"
                    },
                    {
                        title: "Advanced Queue Problems",
                        description: "Complex problems like implementing queues using stacks and vice versa.",
                        prompt: "Solve advanced queue problems:\n1. Implement Queue using Two Stacks:\n   - Two approaches:\n     a) Costly enqueue\n     b) Costly dequeue (better)\n   - For each:\n     * Algorithm explanation\n     * Amortized analysis\n     * Complete implementation\n   - Why approach B is better\n2. Implement Stack using Two Queues:\n   - Two approaches:\n     a) Costly push\n     b) Costly pop\n   - Complete implementations\n3. Implement Stack using One Queue:\n   - Clever trick\n   - Implementation\n4. LRU Cache Using Queue:\n   - Deque + HashMap\n   - O(1) operations\n   - Complete implementation\n5. Design Circular Deque:\n   - All operations O(1)\n   - Complete implementation\n6. Maximum of All Subarrays of Size K:\n   - Using deque\n   - O(n) solution\n   - Detailed walkthrough\n7. First Non-Repeating Character in Stream:\n   - Queue + frequency map\n   - Implementation\n8. Design Hit Counter:\n   - Queue-based solution\n   - Time-efficient implementation\n9. Provide complete code for all 8 problems with detailed comments"
                    }
                ]
            },
            "Trees": {
                description: "Hierarchical data structure with nodes connected by edges, forming a tree-like structure.",
                subtopics: [
                    {
                        title: "Binary Trees",
                        description: "Trees where each node has at most two children with basic operations.",
                        prompt: "Teach me binary trees comprehensively:\n1. Tree Terminology:\n   - Root, parent, child, leaf, sibling\n   - Height, depth, level\n   - Subtree\n   - Visual examples\n2. Binary Tree Properties:\n   - Max nodes at level i: 2^i\n   - Max nodes with height h: 2^(h+1) - 1\n   - Min height for n nodes: log‚ÇÇ(n+1) - 1\n3. Types of Binary Trees:\n   - Full binary tree\n   - Complete binary tree\n   - Perfect binary tree\n   - Balanced vs unbalanced\n   - Visual examples of each\n4. Node Structure:\n   - Data, left, right pointers\n   - Python class implementation\n5. Basic Operations:\n   - Insertion (level order)\n   - Deletion\n   - Searching\n   - Finding height\n   - Counting nodes\n6. Common Problems:\n   - Maximum depth\n   - Diameter of tree\n   - Path sum\n   - Symmetric tree\n   - Same tree\n7. Provide complete implementations and 5 practice problems"
                    },
                    {
                        title: "Binary Search Trees (BST)",
                        description: "Ordered binary trees where left child < parent < right child.",
                        prompt: "Master Binary Search Trees:\n1. BST Property:\n   - For each node: left < node < right\n   - Applies to entire subtrees\n   - Visual example\n   - Why this property is powerful\n2. BST Operations:\n   a) Search:\n      - Recursive and iterative\n      - O(h) where h is height\n      - Code implementation\n   b) Insertion:\n      - Find position using BST property\n      - Recursive and iterative\n      - Implementation\n   c) Deletion (3 cases):\n      - Node is leaf\n      - Node has one child\n      - Node has two children (successor/predecessor)\n      - Detailed explanation of each\n      - Complete implementation\n   d) Find Min/Max\n   e) Find Successor/Predecessor\n3. Inorder gives Sorted Order:\n   - Why?\n   - Proof and example\n4. BST Problems:\n   - Validate BST\n   - Kth smallest element\n   - Lowest common ancestor\n   - Convert sorted array to BST\n   - Range sum query\n5. Time Complexity Analysis:\n   - Best case: O(log n) - balanced\n   - Worst case: O(n) - skewed\n   - Need for balanced BSTs\n6. Provide complete BST class with all operations and 5 problems"
                    },
                    {
                        title: "Tree Traversals",
                        description: "Methods to visit all nodes: inorder, preorder, postorder, and level order.",
                        prompt: "Master all tree traversals:\n1. Depth-First Traversals:\n   a) Inorder (Left-Root-Right):\n      - Recursive implementation\n      - Iterative using stack\n      - Use case: BST gives sorted order\n   b) Preorder (Root-Left-Right):\n      - Recursive implementation\n      - Iterative using stack\n      - Use case: tree copy, prefix expression\n   c) Postorder (Left-Right-Root):\n      - Recursive implementation\n      - Iterative using stack (tricky)\n      - Use case: tree deletion, postfix expression\n2. Example tree walkthrough for each\n3. Breadth-First Traversal:\n   - Level Order using queue\n   - Implementation\n   - Level-by-level separation\n4. Morris Traversal:\n   - O(1) space traversal\n   - Using threaded binary tree concept\n   - Inorder Morris traversal\n   - When to use\n5. Traversal Applications:\n   - Construct tree from traversals\n   - Serialize/deserialize tree\n6. Special Traversals:\n   - Vertical order\n   - Diagonal traversal\n   - Boundary traversal\n   - Zigzag level order\n7. For each traversal:\n   - Visual step-by-step\n   - Recursive code\n   - Iterative code\n   - Time/space complexity\n8. Provide 6 traversal problems with solutions"
                    },
                    {
                        title: "Balanced Trees",
                        description: "Self-balancing trees: AVL, Red-Black, Splay, and Treap trees.",
                        prompt: "Understand balanced trees:\n1. Why Balance Matters:\n   - Skewed BST becomes O(n)\n   - Balance ensures O(log n)\n2. AVL Trees:\n   - Balance factor: |height(left) - height(right)| ‚â§ 1\n   - Rotations: LL, RR, LR, RL\n   - Visual examples of each rotation\n   - Insertion with rebalancing\n   - When to use which rotation\n   - Height always O(log n)\n   - Implementation overview\n3. Red-Black Trees:\n   - Properties (5 rules)\n   - Why they're less strictly balanced than AVL\n   - Recoloring and rotations\n   - Insertion cases\n   - Used in: TreeMap (Java), map (C++)\n   - AVL vs Red-Black comparison\n4. Splay Trees:\n   - Self-adjusting via splaying\n   - Recent accesses become faster\n   - Amortized O(log n)\n   - Use case: caching\n5. Treap:\n   - BST by key + heap by priority\n   - Randomized balance\n   - Overview\n6. Comparison Table:\n   - AVL: strict balance, faster lookups\n   - Red-Black: less strict, faster insertions\n   - When to use each\n7. Focus on intuition and use cases\nProvide visual rotations and high-level implementations"
                    },
                    {
                        title: "Segment Trees",
                        description: "Tree structure for efficient range queries and updates.",
                        prompt: "Master Segment Trees:\n1. What Problem Does It Solve?\n   - Range queries (sum, min, max) in O(log n)\n   - Point/range updates in O(log n)\n   - Better than prefix sum for updates\n2. Structure:\n   - Complete binary tree\n   - Leaves are array elements\n   - Internal nodes store aggregate\n   - Array representation\n   - Size: ~4n for safety\n3. Building Segment Tree:\n   - Recursive construction\n   - Example: arr = [1,3,5,7,9,11]\n   - Build step-by-step\n   - Code implementation\n   - Time: O(n)\n4. Range Query:\n   - Query [L,R]\n   - Recursive approach\n   - Which nodes to consider\n   - Example walkthrough\n   - Code\n   - Time: O(log n)\n5. Point Update:\n   - Update arr[i] = value\n   - Propagate to ancestors\n   - Code\n   - Time: O(log n)\n6. Range Update with Lazy Propagation:\n   - Problem: range updates are O(n)\n   - Lazy propagation concept\n   - Lazy array to defer updates\n   - Update and query with lazy\n   - Complete implementation\n7. Applications:\n   - Range sum/min/max queries\n   - Count elements in range\n8. Provide complete SegmentTree class and 4 problems"
                    },
                    {
                        title: "Fenwick Trees (Binary Indexed Trees)",
                        description: "Efficient data structure for prefix sums and range queries.",
                        prompt: "Learn Fenwick Trees (BIT):\n1. What is Fenwick Tree?\n   - Efficient prefix sum queries: O(log n)\n   - Point updates: O(log n)\n   - Less code than segment tree\n2. Key Insight:\n   - Each index stores sum of a range\n   - Range determined by bits\n   - tree[i] stores sum from (i - (i & -i) + 1) to i\n3. Bit Operations:\n   - i & -i: isolates rightmost set bit\n   - Example: 12 & -12 = 4\n   - Why this works\n4. Operations:\n   a) Update (add delta to index i):\n      - Algorithm\n      - Code\n      - Visual example\n   b) Prefix Sum (sum from 1 to i):\n      - Algorithm\n      - Code\n      - Example\n   c) Range Sum [L, R]:\n      - prefixSum(R) - prefixSum(L-1)\n5. Construction:\n   - Build from array\n   - O(n log n) or O(n) approach\n6. Implementation:\n   - Complete Python class\n   - 1-indexed for simplicity\n7. Fenwick vs Segment Tree:\n   - Fenwick: simpler, less memory, only for invertible operations\n   - Segment: more flexible, supports min/max\n8. 2D Fenwick Tree:\n   - For matrix range sum\n   - Brief overview\n9. Problems:\n   - Range sum query mutable\n   - Count smaller after self\n   - Count inversions\n10. Provide complete code and 3 problems"
                    },
                    {
                        title: "Heaps",
                        description: "Complete binary trees with heap property: min-heap and max-heap.",
                        prompt: "Deep dive into Heaps:\n1. Heap Property:\n   - Min-heap: parent ‚â§ children\n   - Max-heap: parent ‚â• children\n   - Complete binary tree\n   - Visual examples\n2. Array Representation:\n   - Parent of i: (i-1)//2\n   - Left child of i: 2*i + 1\n   - Right child of i: 2*i + 2\n   - Example showing mapping\n3. Heap Operations:\n   a) Insert:\n      - Add at end\n      - Heapify up (bubble up)\n      - Step-by-step example\n      - Code\n      - Time: O(log n)\n   b) Extract Min/Max:\n      - Remove root\n      - Move last to root\n      - Heapify down (bubble down)\n      - Example\n      - Code\n      - Time: O(log n)\n   c) Heapify:\n      - Convert array to heap\n      - Bottom-up approach\n      - Time: O(n) - proof\n4. Build Heap:\n   - From unsorted array\n   - Code implementation\n5. Heap Sort:\n   - Build max-heap\n   - Extract elements\n   - In-place sorting\n   - Complete implementation\n   - Time: O(n log n), Space: O(1)\n6. Applications:\n   - Priority queue (covered separately)\n   - Kth largest/smallest\n   - Median maintenance\n7. Python heapq:\n   - Functions and usage\n   - Creating max-heap workaround\n8. Problems:\n   - Kth largest in array\n   - Top K frequent\n   - Merge K sorted\n   - Find median from stream\n9. Provide complete MinHeap class and 5 problems"
                    },
                    {
                        title: "Advanced Tree Algorithms",
                        description: "Heavy-Light Decomposition, Centroid Decomposition, and LCA algorithms.",
                        prompt: "Learn advanced tree algorithms:\n1. Lowest Common Ancestor (LCA):\n   a) Naive: O(n) per query\n   b) Binary Lifting:\n      - Preprocess ancestors at powers of 2\n      - Lift in O(log n)\n      - Complete implementation\n      - Preprocessing: O(n log n)\n      - Query: O(log n)\n   c) Applications: distance between nodes\n2. Heavy-Light Decomposition (HLD):\n   - Decompose tree into chains\n   - Path queries become range queries\n   - Concept explanation\n   - When to use: path updates/queries\n   - High-level overview\n3. Centroid Decomposition:\n   - Recursively find centroid\n   - Build centroid tree\n   - Applications: distance queries\n   - Concept explanation\n4. Euler Tour:\n   - Flatten tree to array\n   - Subtree queries become range queries\n   - Implementation\n5. Tree Flattening:\n   - DFS numbering\n   - Applications\n6. Diameter of Tree:\n   - Two BFS/DFS approach\n   - DP approach\n   - Complete solution\n7. Tree Isomorphism:\n   - Checking if trees are same structure\n   - Hashing approach\n8. Provide detailed explanations for:\n   - LCA with binary lifting (complete code)\n   - Euler tour technique\n   - 3 advanced tree problems\nFocus on LCA and practical techniques"
                    }
                ]
            },
            "Graphs": {
                description: "Non-linear data structure with vertices connected by edges, representing relationships.",
                subtopics: [
                    {
                        title: "Graph Representation",
                        description: "Different ways to represent graphs: adjacency list, adjacency matrix, and edge list.",
                        prompt: "Teach me graph representations:\n1. Graph Terminology:\n   - Vertex (node), edge, degree\n   - Directed vs undirected\n   - Weighted vs unweighted\n   - Cyclic vs acyclic (DAG)\n   - Connected vs disconnected\n   - Visual examples\n2. Adjacency Matrix:\n   - 2D array: mat[i][j] = 1 if edge exists\n   - Example graph with matrix\n   - Pros: O(1) edge lookup, simple\n   - Cons: O(V¬≤) space, dense graphs\n   - When to use\n   - Implementation in Python\n3. Adjacency List:\n   - Array/dict of lists\n   - Example graph with lists\n   - Pros: O(V+E) space, sparse graphs\n   - Cons: O(degree) edge lookup\n   - When to use (most common)\n   - Implementation using dict\n4. Edge List:\n   - List of (u, v, weight) tuples\n   - When to use: Kruskal's MST\n   - Example\n5. Comparison Table:\n   - Space, time for operations\n   - Which to use when\n6. Weighted Graph Representation:\n   - Storing weights in each method\n7. Provide complete Graph class with all 3 representations"
                    },
                    {
                        title: "Graph Traversal",
                        description: "Breadth-First Search (BFS) and Depth-First Search (DFS) algorithms.",
                        prompt: "Master graph traversal:\n1. Depth-First Search (DFS):\n   a) Recursive DFS:\n      - Algorithm\n      - Step-by-step on example graph\n      - Code implementation\n      - Time: O(V+E), Space: O(V)\n   b) Iterative DFS (using stack):\n      - Implementation\n      - Difference from recursive\n   c) Applications:\n      - Path finding\n      - Cycle detection\n      - Topological sort\n      - Connected components\n2. Breadth-First Search (BFS):\n   a) Using queue:\n      - Algorithm\n      - Level-by-level traversal\n      - Step-by-step example\n      - Code implementation\n      - Time: O(V+E), Space: O(V)\n   b) Applications:\n      - Shortest path (unweighted)\n      - Level order traversal\n      - Peer-to-peer networks\n3. DFS vs BFS:\n   - When to use which\n   - Comparison table\n4. Visited Array:\n   - Why needed\n   - Handling disconnected graphs\n5. Problems:\n   - Number of islands\n   - Clone graph\n   - Course schedule\n   - Word ladder\n   - All paths from source to target\n6. Provide complete implementations and 5 practice problems"
                    },
                    {
                        title: "Shortest Path Algorithms",
                        description: "Finding shortest paths: Dijkstra, Bellman-Ford, and Floyd-Warshall algorithms.",
                        prompt: "Master shortest path algorithms:\n1. Dijkstra's Algorithm:\n   - For: Weighted graphs, non-negative weights\n   - Greedy approach with priority queue\n   - Algorithm step-by-step:\n     * Initialize distances\n     * Pick min distance unvisited\n     * Update neighbors\n   - Example walkthrough\n   - Implementation using min-heap\n   - Time: O((V+E) log V) with heap\n   - Why negative weights break it\n2. Bellman-Ford Algorithm:\n   - For: Weighted graphs, handles negative weights\n   - Detects negative cycles\n   - Algorithm: Relax all edges V-1 times\n   - Why V-1 iterations?\n   - Example\n   - Implementation\n   - Time: O(VE)\n   - Negative cycle detection\n3. Floyd-Warshall Algorithm:\n   - For: All-pairs shortest paths\n   - DP approach: try all intermediate vertices\n   - Algorithm with 3 nested loops\n   - Example with matrix updates\n   - Implementation\n   - Time: O(V¬≥)\n   - Space: O(V¬≤)\n   - Path reconstruction\n4. Comparison:\n   - Single-source vs all-pairs\n   - Negative weights handling\n   - When to use which\n5. Problems:\n   - Network delay time\n   - Cheapest flights with K stops\n   - Path with min effort\n6. Provide complete code for all 3 algorithms and 4 problems"
                    },
                    {
                        title: "Minimum Spanning Tree",
                        description: "Finding minimum cost spanning trees using Kruskal's and Prim's algorithms.",
                        prompt: "Learn Minimum Spanning Tree (MST):\n1. What is MST?\n   - Spanning tree: connects all vertices\n   - Minimum: min total edge weight\n   - V vertices need V-1 edges\n   - Applications: network design\n2. Kruskal's Algorithm:\n   - Greedy: sort edges, pick min without cycle\n   - Uses Union-Find for cycle detection\n   - Algorithm steps:\n     * Sort edges by weight\n     * For each edge, if connects diff components, add it\n   - Example walkthrough\n   - Implementation with Union-Find\n   - Time: O(E log E)\n3. Union-Find (Disjoint Set):\n   - Operations: find, union\n   - Path compression\n   - Union by rank\n   - Complete implementation\n   - Amortized O(Œ±(n)) ‚âà O(1)\n4. Prim's Algorithm:\n   - Greedy: grow tree from starting vertex\n   - Uses priority queue\n   - Algorithm steps:\n     * Start from any vertex\n     * Pick min edge to new vertex\n   - Example walkthrough\n   - Implementation\n   - Time: O((V+E) log V) with heap\n5. Kruskal vs Prim:\n   - When to use which\n   - Sparse vs dense graphs\n6. Problems:\n   - Min cost to connect all points\n   - Connecting cities with min cost\n7. Provide complete implementations of both algorithms"
                    },
                    {
                        title: "Topological Sort",
                        description: "Linear ordering of vertices in directed acyclic graphs.",
                        prompt: "Master topological sorting:\n1. What is Topological Sort?\n   - Linear ordering of DAG vertices\n   - For edge u‚Üív, u comes before v\n   - Only for DAGs (no cycles)\n   - Multiple valid orderings possible\n   - Applications: task scheduling, course prerequisites\n2. Kahn's Algorithm (BFS-based):\n   - Track in-degrees\n   - Process vertices with in-degree 0\n   - Algorithm steps\n   - Example walkthrough\n   - Cycle detection: if can't process all vertices\n   - Implementation\n   - Time: O(V+E)\n3. DFS-based Approach:\n   - Post-order DFS\n   - Reverse the finishing order\n   - Algorithm\n   - Example\n   - Implementation\n   - Time: O(V+E)\n4. Detecting Cycles:\n   - Using DFS with colors (white/gray/black)\n   - Using Kahn's algorithm\n5. Applications:\n   - Course Schedule problem\n   - Build order\n   - Alien dictionary\n6. Problems:\n   - Course Schedule I & II\n   - Alien Dictionary\n   - Minimum height trees\n7. Provide both implementations and 4 problems with solutions"
                    },
                    {
                        title: "Connected Components",
                        description: "Finding strongly connected components and articulation points.",
                        prompt: "Learn about graph connectivity:\n1. Connected Components (Undirected):\n   - Using DFS/BFS\n   - Count components\n   - Implementation\n2. Strongly Connected Components (SCCs) in Directed Graphs:\n   - Definition: every vertex reaches every other\n   - Kosaraju's Algorithm:\n     * DFS on original graph (get finish times)\n     * DFS on transposed graph in decreasing finish time\n     * Why it works\n     * Step-by-step example\n     * Implementation\n     * Time: O(V+E)\n   - Tarjan's Algorithm:\n     * Single DFS with lowlink values\n     * Using stack\n     * Concept explanation\n     * Time: O(V+E)\n3. Bridges (Cut Edges):\n   - Edge whose removal disconnects graph\n   - Finding using DFS with discovery times\n   - Algorithm\n   - Implementation\n4. Articulation Points (Cut Vertices):\n   - Vertex whose removal disconnects graph\n   - Finding using DFS\n   - Algorithm\n   - Implementation\n5. Biconnected Components:\n   - Concept\n   - Finding algorithm\n6. Applications:\n   - Network reliability\n   - Social network analysis\n7. Problems:\n   - Critical connections\n   - Number of provinces\n8. Provide complete implementations for Kosaraju's, bridges, articulation points"
                    },
                    {
                        title: "Network Flow",
                        description: "Maximum flow algorithms: Ford-Fulkerson, Edmonds-Karp, and Dinic's algorithm.",
                        prompt: "Understand network flow:\n1. Maximum Flow Problem:\n   - Flow network: source s, sink t, capacities\n   - Flow rules: capacity constraint, conservation\n   - Goal: maximize flow from s to t\n   - Applications: matching, min cut\n2. Ford-Fulkerson Method:\n   - Find augmenting paths\n   - Increase flow along path\n   - Residual graph concept\n   - Algorithm outline\n   - Depends on path-finding method\n3. Edmonds-Karp Algorithm:\n   - Ford-Fulkerson with BFS for paths\n   - Guaranteed polynomial time\n   - Algorithm steps\n   - Example walkthrough\n   - Implementation\n   - Time: O(VE¬≤)\n4. Dinic's Algorithm:\n   - Level graph + blocking flow\n   - Faster: O(V¬≤E)\n   - High-level explanation\n5. Min-Cut Max-Flow Theorem:\n   - Max flow = Min cut capacity\n   - Applications\n6. Bipartite Matching:\n   - As max flow problem\n   - Hungarian algorithm (brief)\n7. Applications:\n   - Assignment problems\n   - Image segmentation\n   - Airline scheduling\n8. Problems:\n   - Maximum flow problem\n   - Bipartite matching\n9. Provide Edmonds-Karp implementation and 2 problems\nNote: Advanced topic, focus on concepts and one implementation"
                    },
                    {
                        title: "Advanced Graph Algorithms",
                        description: "Eulerian/Hamiltonian paths, bipartite matching, and advanced shortest paths.",
                        prompt: "Explore advanced graph algorithms:\n1. Eulerian Path/Circuit:\n   - Eulerian circuit: visits every edge exactly once\n   - Conditions: all vertices even degree (circuit) or exactly 2 odd (path)\n   - Hierholzer's Algorithm\n   - Implementation\n   - Application: Chinese Postman\n2. Hamiltonian Path/Cycle:\n   - Visits every vertex exactly once\n   - NP-complete (no efficient algorithm)\n   - Backtracking approach\n   - Concept and example\n3. Bipartite Graphs:\n   - Definition: 2-colorable\n   - Checking using BFS/DFS\n   - Bipartite matching (covered in flow)\n   - Applications\n4. Graph Coloring:\n   - Chromatic number\n   - Greedy coloring\n   - NP-complete for optimal\n5. A* Algorithm:\n   - Dijkstra + heuristic\n   - Heuristic function h(n)\n   - When to use: goal-directed search\n   - Implementation outline\n6. Johnson's Algorithm:\n   - All-pairs shortest path\n   - Reweighting + Dijkstra\n   - Handles negative weights\n   - O(V¬≤ log V + VE)\n7. Problems:\n   - Reconstruct itinerary (Eulerian)\n   - Is graph bipartite\n   - Shortest path with A*\n8. Provide implementations for:\n   - Eulerian path\n   - Bipartite check\n   - A* algorithm outline"
                    }
                ]
            },
            "Hashing": {
                description: "Technique for mapping data to fixed-size values using hash functions for fast access.",
                subtopics: [
                    {
                        title: "Hash Tables",
                        description: "Data structure implementing associative arrays using hash functions.",
                        prompt: "Learn hash tables in depth:\n1. What are Hash Tables?\n   - Key-value pairs\n   - O(1) average insert, search, delete\n   - Real-world: dictionaries, caches\n2. How Hash Tables Work:\n   - Hash function maps key to index\n   - Array stores values\n   - Example: storing {\"Alice\": 25, \"Bob\": 30}\n3. Hash Function:\n   - Takes key, returns index\n   - Must be deterministic\n   - Should distribute uniformly\n4. Basic Operations:\n   - Insert: hash(key) ‚Üí index, store value\n   - Search: hash(key) ‚Üí index, retrieve\n   - Delete: mark as deleted\n   - Implementation\n5. Load Factor:\n   - n/m (items/capacity)\n   - When to resize\n   - Dynamic resizing\n6. Python dict:\n   - Built-in hash table\n   - Methods and usage\n7. Provide complete HashTable implementation with all operations"
                    },
                    {
                        title: "Hash Functions",
                        description: "Functions that map data to fixed-size values with good distribution properties.",
                        prompt: "Master hash functions:\n1. Properties of Good Hash Functions:\n   - Deterministic\n   - Uniform distribution\n   - Fast computation\n   - Minimize collisions\n2. Common Hash Functions:\n   a) Division Method:\n      - h(k) = k mod m\n      - Choose m (prime number)\n   b) Multiplication Method:\n      - h(k) = floor(m * (kA mod 1))\n      - A ‚âà 0.618\n   c) Universal Hashing:\n      - Family of hash functions\n      - Random selection\n3. Hashing Different Data Types:\n   - Integers: direct mod\n   - Strings: polynomial rolling hash\n   - Objects: combine field hashes\n4. Python's hash():\n   - Built-in function\n   - __hash__() method\n   - hash() vs id()\n5. Avalanche Effect:\n   - Small input change ‚Üí large hash change\n   - Important for security\n6. Implement custom hash function for strings and objects"
                    },
                    {
                        title: "Collision Resolution",
                        description: "Handling collisions: chaining, open addressing, and double hashing.",
                        prompt: "Handle collisions expertly:\n1. What are Collisions?\n   - Two keys hash to same index\n   - Inevitable (pigeonhole principle)\n2. Separate Chaining:\n   - Array of linked lists\n   - Each slot can hold multiple items\n   - Insert: add to list at index\n   - Search: traverse list\n   - Pros: simple, handles high load\n   - Cons: extra space for pointers\n   - Implementation\n3. Open Addressing:\n   - All elements in array\n   - Probe for next open slot\n   a) Linear Probing:\n      - Try h(k), h(k)+1, h(k)+2, ...\n      - Clustering problem\n   b) Quadratic Probing:\n      - Try h(k), h(k)+1¬≤, h(k)+2¬≤, ...\n      - Reduces clustering\n   c) Double Hashing:\n      - Try h1(k), h1(k)+h2(k), h1(k)+2*h2(k), ...\n      - Best distribution\n   - Deletion: tombstones\n   - Implementation\n4. Comparison:\n   - When to use which\n   - Performance characteristics\n5. Implement hash table with both chaining and open addressing"
                    },
                    {
                        title: "Applications",
                        description: "Using hashing for frequency counting, sets, maps, and caching.",
                        prompt: "Explore hashing applications:\n1. Frequency Counting:\n   - Count character/word frequencies\n   - Using dict/Counter\n   - Applications in anagrams\n2. Two Sum Problem:\n   - Using hash map\n   - O(n) solution\n   - Implementation\n3. Group Anagrams:\n   - Hash by sorted string\n   - Solution\n4. LRU Cache:\n   - Hash map + doubly linked list\n   - O(1) get and put\n   - Complete implementation\n5. Sets:\n   - Unique elements\n   - Fast membership testing\n   - Set operations\n6. Caching/Memoization:\n   - Function result caching\n   - @lru_cache\n7. Database Indexing:\n   - Hash indexes\n   - When to use\n8. Problems:\n   - Two sum\n   - Group anagrams\n   - First unique character\n   - Longest substring without repeating\n9. Provide 5 complete problem solutions using hashing"
                    },
                    {
                        title: "String Hashing",
                        description: "Specialized hashing techniques for strings and text processing.",
                        prompt: "This is covered in the Strings section. Please refer to 'String Hashing' under the Strings topic for comprehensive coverage of polynomial hashing, rolling hash, and applications in pattern matching."
                    },
                    {
                        title: "Advanced Hashing",
                        description: "Consistent hashing, bloom filters, and cryptographic hash functions.",
                        prompt: "Learn advanced hashing:\n1. Consistent Hashing:\n   - Problem: servers added/removed in distributed systems\n   - Hash ring concept\n   - Virtual nodes\n   - Applications: load balancing, distributed caches\n   - High-level explanation\n2. Bloom Filters:\n   - Probabilistic data structure\n   - Space-efficient set membership\n   - False positives possible, no false negatives\n   - Multiple hash functions\n   - Applications: web browsers, databases\n   - Implementation overview\n3. Count-Min Sketch:\n   - Approximate frequency counting\n   - Space-efficient\n   - Concept\n4. Cryptographic Hash Functions:\n   - One-way function\n   - SHA-256, MD5\n   - Properties: pre-image resistance, collision resistance\n   - Applications: passwords, blockchain\n5. Perfect Hashing:\n   - No collisions\n   - Two-level hashing\n   - When to use\n6. Cuckoo Hashing:\n   - Two hash functions, two tables\n   - Worst-case O(1) lookup\n   - Concept\n7. Focus on concepts and use cases"
                    }
                ]
            },
            "Heaps & Priority Queues": {
                description: "Complete binary trees with heap property for efficient priority-based operations.",
                subtopics: [
                    {
                        title: "Heap Properties",
                        description: "Min-heap and max-heap properties and their characteristics.",
                        prompt: "This topic is thoroughly covered in the Trees section under 'Heaps'. Please refer to that section for complete coverage of heap properties, operations, and applications."
                    },
                    {
                        title: "Heap Operations",
                        description: "Core operations: insertion, deletion, heapify, and extract operations.",
                        prompt: "This topic is thoroughly covered in the Trees section under 'Heaps'. Please refer to that section for complete coverage of all heap operations with detailed implementations."
                    },
                    {
                        title: "Heap Sort",
                        description: "Sorting algorithm using heap data structure with O(n log n) complexity.",
                        prompt: "This topic is thoroughly covered in the Trees section under 'Heaps'. Please refer to that section for complete heap sort algorithm explanation and implementation."
                    },
                    {
                        title: "Priority Queue Implementation",
                        description: "Implementing priority queues using heaps for efficient operations.",
                        prompt: "This topic is thoroughly covered in the Queues section under 'Priority Queues'. Please refer to that section for complete priority queue implementation using heaps."
                    },
                    {
                        title: "Advanced Heap Types",
                        description: "Binomial heaps, Fibonacci heaps, and other specialized heap structures.",
                        prompt: "Learn advanced heaps (competition-level):\n1. Binomial Heap:\n   - Collection of binomial trees\n   - Merge in O(log n)\n   - Structure and properties\n   - When to use\n2. Fibonacci Heap:\n   - Lazy operations\n   - Amortized O(1) for decrease-key\n   - Used in Dijkstra, Prim optimizations\n   - Structure overview\n   - Complex but theoretically optimal\n3. Pairing Heap:\n   - Simpler than Fibonacci\n   - Good amortized performance\n   - Overview\n4. Comparison:\n   - Binary vs Binomial vs Fibonacci\n   - Time complexities\n   - When to use what\n5. Focus on concepts; binary heap sufficient for most cases"
                    },
                    {
                        title: "Heap Applications",
                        description: "Applications in median maintenance, kth largest element, and merge k sorted lists.",
                        prompt: "Apply heaps to solve problems:\n1. Find Median from Data Stream:\n   - Two heaps: max-heap (left) + min-heap (right)\n   - Balance heaps\n   - Median is top of one or both\n   - Complete implementation\n2. Kth Largest Element:\n   - Min-heap of size k\n   - Keep k largest elements\n   - Top is kth largest\n   - O(n log k)\n   - Implementation\n3. Merge K Sorted Lists:\n   - Min-heap with (value, list_index, element_index)\n   - Extract min, add next from same list\n   - O(N log k) where N is total elements\n   - Implementation\n4. Top K Frequent Elements:\n   - Frequency map + min-heap of size k\n   - Solution\n5. Task Scheduler:\n   - Using max-heap for frequencies\n   - Greedy with cooling\n   - Solution\n6. Sliding Window Maximum:\n   - Can use heap (or deque is better)\n   - Approach explanation\n7. Provide complete code for problems 1-5"
                    }
                ]
            },
            "Searching & Sorting": {
                description: "Fundamental algorithms for finding elements and arranging data in order.",
                subtopics: [
                    {
                        title: "Searching Algorithms",
                        description: "Linear search, binary search, and ternary search techniques.",
                        prompt: "Master searching algorithms:\n1. Linear Search:\n   - Sequential checking\n   - Works on unsorted data\n   - O(n) time\n   - Implementation\n2. Binary Search:\n   - Requires sorted array\n   - Divide and conquer\n   - O(log n) time\n   - Iterative implementation\n   - Recursive implementation\n   - Common pitfalls (integer overflow in mid calculation)\n3. Binary Search Variations:\n   - Find first occurrence\n   - Find last occurrence\n   - Find insertion position\n   - Count occurrences\n4. Binary Search on Answer:\n   - Search space is answer range, not array\n   - Check feasibility function\n   - Example: Square root\n   - Example: Minimum time to complete tasks\n5. Ternary Search:\n   - For unimodal functions\n   - Find maximum/minimum\n   - O(log‚ÇÉ n)\n6. Problems:\n   - Search in rotated sorted array\n   - Find peak element\n   - Search 2D matrix\n7. Provide implementations and 5 binary search problems"
                    },
                    {
                        title: "Basic Sorting Algorithms",
                        description: "Bubble sort, selection sort, and insertion sort with their characteristics.",
                        prompt: "Learn basic sorting algorithms:\n1. Bubble Sort:\n   - Compare adjacent, swap if wrong order\n   - Multiple passes until sorted\n   - O(n¬≤) time, O(1) space\n   - Stable\n   - Implementation with optimization\n   - When to use: nearly sorted data\n2. Selection Sort:\n   - Find minimum, place at beginning\n   - O(n¬≤) time, O(1) space\n   - Unstable (can be made stable)\n   - Implementation\n   - When to use: min memory writes needed\n3. Insertion Sort:\n   - Insert each element in sorted portion\n   - O(n¬≤) worst, O(n) best\n   - O(1) space\n   - Stable\n   - Implementation\n   - When to use: small arrays, nearly sorted\n4. Visual Comparison:\n   - Step-by-step with example array\n5. Comparison Table:\n   - Time, space, stability\n6. Provide all 3 implementations with detailed comments"
                    },
                    {
                        title: "Efficient Sorting Algorithms",
                        description: "Merge sort, quick sort, and heap sort with O(n log n) complexity.",
                        prompt: "Master efficient sorting:\n1. Merge Sort:\n   - Divide: split array\n   - Conquer: sort halves\n   - Combine: merge sorted halves\n   - O(n log n) time, O(n) space\n   - Stable\n   - Implementation (recursive)\n   - When to use: need stability, linked lists\n2. Quick Sort:\n   - Pick pivot\n   - Partition around pivot\n   - Recursively sort partitions\n   - Average O(n log n), worst O(n¬≤)\n   - O(log n) space for recursion\n   - Unstable\n   - Implementation (with Lomuto/Hoare partition)\n   - Randomized quicksort\n   - When to use: general purpose, in-place needed\n3. Heap Sort:\n   - Build max-heap\n   - Extract max repeatedly\n   - O(n log n) time, O(1) space\n   - Unstable\n   - Implementation\n   - When to use: guaranteed O(n log n), O(1) space\n4. Comparison:\n   - Which is best when?\n   - Real-world usage\n5. Provide all 3 complete implementations"
                    },
                    {
                        title: "Specialized Sorting",
                        description: "Counting sort, radix sort, and bucket sort for specific data types.",
                        prompt: "Learn non-comparison sorts:\n1. Counting Sort:\n   - Count frequency of each value\n   - Calculate positions\n   - Place elements\n   - O(n+k) time where k is range\n   - O(k) space\n   - Stable\n   - When: small range of integers\n   - Implementation\n2. Radix Sort:\n   - Sort by each digit (LSD or MSD)\n   - Use counting sort as subroutine\n   - O(d*(n+k)) where d is digits\n   - Stable\n   - When: fixed-length integers/strings\n   - Implementation\n3. Bucket Sort:\n   - Distribute into buckets\n   - Sort each bucket\n   - Concatenate\n   - O(n+k) average\n   - When: uniformly distributed floats\n   - Implementation\n4. Why These Beat O(n log n):\n   - Not comparison-based\n   - Use problem constraints\n5. Provide all 3 implementations with examples"
                    },
                    {
                        title: "Sorting Properties",
                        description: "Understanding stable vs unstable, in-place vs out-of-place sorting.",
                        prompt: "Understand sorting properties:\n1. Stable vs Unstable:\n   - Stable: preserves relative order of equal elements\n   - Why it matters: sorting by multiple keys\n   - Which algorithms are stable?\n   - Example showing stability\n2. In-place vs Out-of-place:\n   - In-place: O(1) or O(log n) extra space\n   - Out-of-place: O(n) extra space\n   - Which algorithms are in-place?\n3. Adaptive:\n   - Performance improves on partially sorted data\n   - Insertion sort is adaptive\n4. Comparison Table:\n   - All major sorts with properties\n   - Time (best/avg/worst)\n   - Space\n   - Stable?\n   - In-place?\n5. How to Make Algorithm Stable:\n   - Add index as tiebreaker\n6. Choosing the Right Sort:\n   - Decision tree based on constraints"
                    },
                    {
                        title: "Sorting Applications",
                        description: "Real-world applications and optimization techniques in sorting.",
                        prompt: "Apply sorting in practice:\n1. Real-World Uses:\n   - Database query results\n   - E-commerce (price, rating)\n   - Contact lists\n   - Search engine results\n2. Python's Timsort:\n   - Hybrid of merge + insertion\n   - Used in Python's sort()\n   - Why it's chosen\n   - Adaptive and stable\n3. Optimizations:\n   - Introsort (quicksort + heapsort fallback)\n   - Three-way partitioning for duplicates\n   - Insertion sort for small subarrays\n4. Sorting Custom Objects:\n   - key parameter\n   - Comparator functions\n   - Multiple sort keys\n5. Partial Sorting:\n   - Finding top k elements\n   - Quickselect algorithm\n6. External Sorting:\n   - Data doesn't fit in memory\n   - External merge sort concept\n7. Problems:\n   - Meeting rooms\n   - Merge intervals\n   - Sort colors (Dutch flag)\n   - Custom sort string\n8. Provide 4 problem solutions using sorting"
                    }
                ]
            },
            "Recursion & Backtracking": {
                description: "Problem-solving techniques using function calls and systematic exploration of solutions.",
                subtopics: [
                    {
                        title: "Recursion Fundamentals",
                        description: "Understanding recursion, base cases, recursive cases, and call stack.",
                        prompt: "Teach me recursion from scratch:\n1. What is Recursion?\n   - Function calling itself\n   - Real-world analogy: Russian dolls, mirrors\n   - When to use recursion vs iteration\n2. Anatomy of Recursion:\n   - Base case(s): when to stop\n   - Recursive case: calling itself with simpler input\n   - Trust the recursion (leap of faith)\n3. Call Stack:\n   - How function calls are stacked\n   - Stack frames\n   - Visualization with factorial(5)\n   - Stack overflow error\n4. Simple Examples:\n   a) Factorial:\n      - Recursive definition\n      - Code implementation\n      - Tracing execution\n   b) Fibonacci:\n      - Recursive tree\n      - Exponential time complexity\n   c) Sum of array\n   d) Power function\n5. Recursion Patterns:\n   - Decreasing by one\n   - Divide and conquer\n   - Multiple recursive calls\n6. Common Mistakes:\n   - Missing base case\n   - Not making progress toward base case\n   - Not returning values properly\n7. Provide 5 beginner recursion problems with detailed solutions"
                    },
                    {
                        title: "Backtracking Algorithms",
                        description: "Systematic exploration of solution space with backtracking technique.",
                        prompt: "Master backtracking:\n1. What is Backtracking?\n   - Exploring all possibilities\n   - Undo when path doesn't work\n   - DFS-like exploration\n   - When to use: combinatorial problems\n2. Backtracking Template:\n   ```\n   def backtrack(candidate):\n       if is_solution(candidate):\n           add_to_result(candidate)\n           return\n       for next_choice in choices:\n           if is_valid(next_choice):\n               make_choice(next_choice)\n               backtrack(next_choice)\n               undo_choice()  # Backtrack!\n   ```\n3. Generate All Subsets:\n   - Include/exclude decision\n   - Recursive tree\n   - Implementation\n   - Time: O(2^n)\n4. Generate All Permutations:\n   - Swap approach\n   - Used array tracking\n   - Implementation\n   - Time: O(n!)\n5. Generate All Combinations:\n   - Start index approach\n   - Implementation\n   - Difference from permutations\n6. Letter Combinations (phone keypad):\n   - Problem walkthrough\n   - Solution\n7. Pruning:\n   - Early termination\n   - Reducing search space\n   - Example in subset sum\n8. Provide backtracking template and 5 problems"
                    },
                    {
                        title: "Classic Backtracking Problems",
                        description: "N-Queens, Sudoku solver, and subset sum problems.",
                        prompt: "Solve classic backtracking problems:\n1. N-Queens Problem:\n   - Place N queens on N√óN board\n   - No two queens attack each other\n   - Approach:\n     * Try placing queen in each row\n     * Check if safe (column, diagonals)\n     * Backtrack if not\n   - How to check diagonals efficiently\n   - Complete implementation\n   - Optimization techniques\n2. Sudoku Solver:\n   - 9√ó9 grid with constraints\n   - Algorithm:\n     * Find empty cell\n     * Try digits 1-9\n     * Check row/column/box validity\n     * Recurse\n     * Backtrack if stuck\n   - Implementation with validity checks\n   - Optimizations: naked singles\n3. Subset Sum:\n   - Find subset with given sum\n   - Include/exclude approach\n   - With and without DP\n   - Implementation\n4. Word Search in Grid:\n   - Find word in 2D board\n   - DFS + backtracking\n   - Mark visited, unmark on backtrack\n   - Implementation\n5. Rat in a Maze:\n   - Find path from start to end\n   - Solution\n6. For each problem:\n   - Clear explanation\n   - Step-by-step approach\n   - Complete code\n   - Time complexity\n   - Pruning strategies"
                    },
                    {
                        title: "Memoization",
                        description: "Top-down dynamic programming technique using memoization.",
                        prompt: "Understand memoization:\n1. What is Memoization?\n   - Caching results of expensive function calls\n   - Top-down DP\n   - Avoiding recomputation\n2. Fibonacci with Memoization:\n   - Naive recursive: O(2^n)\n   - With memo: O(n)\n   - Implementation using dict\n   - Visualization showing saved calls\n3. Python Decorators:\n   - @lru_cache decorator\n   - functools.lru_cache\n   - maxsize parameter\n   - Example usage\n4. When to Use Memoization:\n   - Overlapping subproblems\n   - Pure functions (same input ‚Üí same output)\n   - Top-down feels more natural\n5. Memoization vs Tabulation:\n   - Comparison table\n   - Pros and cons\n   - Conversion process\n6. Problems:\n   - Climbing stairs with memo\n   - Longest increasing path in matrix\n   - Word break\n   - Decode ways\n7. Provide examples showing naive vs memoized for each"
                    },
                    {
                        title: "Advanced Backtracking",
                        description: "Complex problems like word search, combination sum, and path finding.",
                        prompt: "Tackle advanced backtracking:\n1. Combination Sum (with duplicates):\n   - Can reuse elements\n   - Avoiding duplicate combinations\n   - Sorting + skipping\n   - Implementation\n2. Palindrome Partitioning:\n   - Partition string into palindromes\n   - Backtracking approach\n   - DP for palindrome check\n   - Solution\n3. Generate Parentheses:\n   - Valid combinations of n pairs\n   - Track open and close counts\n   - When can we add '(' or ')'\n   - Implementation\n4. Word Break II:\n   - All possible sentences\n   - Backtracking + memo\n   - Solution\n5. Restore IP Addresses:\n   - All valid IPs from string\n   - Constraints checking\n   - Implementation\n6. Path Sum III (tree paths):\n   - All root-to-leaf paths\n   - Backtracking on tree\n   - Solution\n7. Optimization Techniques:\n   - Early termination\n   - Sorting for pruning\n   - Memoization in backtracking\n8. Provide complete solutions for all 6 problems"
                    },
                    {
                        title: "Recursion Optimization",
                        description: "Tail recursion, space optimization, and avoiding common pitfalls.",
                        prompt: "Optimize recursive solutions:\n1. Tail Recursion:\n   - Definition: recursive call is last operation\n   - Tail call optimization (TCO)\n   - Converting to tail recursive\n   - Example: factorial tail recursive\n   - Python doesn't do TCO (explain why)\n2. Space Optimization:\n   - Recursion ‚Üí iteration conversion\n   - Using explicit stack\n   - Example: tree traversal iterative\n3. Avoiding Stack Overflow:\n   - Recursion depth limits\n   - sys.setrecursionlimit (Python)\n   - When recursion is too deep\n   - Converting to iterative\n4. Common Recursion Pitfalls:\n   - Forgetting base case\n   - Infinite recursion\n   - Not returning values\n   - Modifying global state\n   - Solutions for each\n5. When NOT to Use Recursion:\n   - Simple iteration is clearer\n   - Very deep recursion\n   - Tail recursion without TCO\n6. Recursion vs Iteration:\n   - Comparison table\n   - Readability vs efficiency\n   - When to use which\n7. Provide examples of:\n   - Tail recursive conversion\n   - Recursion to iteration\n   - Stack-based solution"
                    }
                ]
            },
            "Dynamic Programming": {
                description: "Optimization technique solving complex problems by breaking them into simpler subproblems.",
                subtopics: [
                    {
                        title: "DP Fundamentals",
                        description: "Overlapping subproblems, optimal substructure, and DP principles.",
                        prompt: "I want to deeply understand Dynamic Programming from scratch. Please teach me:\n1. What is Dynamic Programming?\n   - Simple definition with real-world analogy\n   - When to use DP vs other approaches\n2. Two key properties:\n   a) Optimal Substructure:\n      - What it means\n      - Example: Fibonacci showing optimal substructure\n   b) Overlapping Subproblems:\n      - What it means\n      - Show recursion tree for Fibonacci illustrating overlaps\n3. Identifying DP problems:\n   - Keywords/patterns that suggest DP\n   - Checklist to verify if problem suits DP\n4. Start with Fibonacci:\n   - Naive recursion (show exponential time)\n   - Add memoization (top-down DP)\n   - Convert to tabulation (bottom-up DP)\n   - Space optimization\n5. Step-by-step framework for solving DP problems:\n   - Define state\n   - Write recurrence relation\n   - Base cases\n   - Implementation approach\n6. Give me 3 beginner problems to practice this framework\nUse clear examples and build intuition before complexity."
                    },
                    {
                        title: "DP Approaches",
                        description: "Top-down (memoization) vs bottom-up (tabulation) approaches.",
                        prompt: "Explain the two DP approaches in depth:\n1. Top-Down (Memoization):\n   - Concept: recursion + caching\n   - When to use\n   - Implementation pattern (decorator/manual cache)\n   - Example: Climbing Stairs\n     * Write recursive solution\n     * Add memoization\n     * Analyze time/space\n2. Bottom-Up (Tabulation):\n   - Concept: iterative, fill table\n   - When to use\n   - Implementation pattern\n   - Same problem: Climbing Stairs\n     * Build DP table\n     * Fill iteratively\n     * Analyze time/space\n3. Comparison:\n   - Pros and cons of each\n   - Stack overflow risk in top-down\n   - Which is more intuitive?\n4. Converting between approaches:\n   - Step-by-step conversion process\n   - Example: convert House Robber both ways\n5. Space Optimization:\n   - When DP table row depends only on previous row\n   - Reduce 2D to 1D\n   - Example optimization\n6. Provide 5 problems:\n   - 2 better suited for top-down\n   - 2 better for bottom-up\n   - 1 to practice both approaches\nShow complete code for each approach."
                    },
                    {
                        title: "Classic DP Problems",
                        description: "Knapsack, LIS, LCS, coin change, and matrix chain multiplication.",
                        prompt: "Teach me classic DP problems that form the foundation:\n\n1. 0/1 Knapsack:\n   - Problem statement with example\n   - Why greedy doesn't work\n   - DP state definition: dp[i][w]\n   - Recurrence relation with explanation\n   - Build DP table step-by-step\n   - Backtracking to find items selected\n   - Code in Python\n   - Variations: Unbounded knapsack, subset sum\n\n2. Longest Increasing Subsequence (LIS):\n   - Problem with example: [10,9,2,5,3,7,101,18]\n   - O(n¬≤) DP solution\n   - O(n log n) binary search solution\n   - Complete implementations\n   - Related: LIS count, printing LIS\n\n3. Longest Common Subsequence (LCS):\n   - Problem with example\n   - 2D DP table\n   - Filling the table\n   - Reconstructing the LCS\n   - Code implementation\n   - Applications: diff tool, DNA matching\n\n4. Coin Change:\n   - Minimum coins to make amount\n   - Recurrence relation\n   - DP solution\n   - Count ways to make change (variant)\n   - Both implementations\n\n5. Matrix Chain Multiplication:\n   - Problem explanation\n   - Why order matters\n   - DP approach\n   - Implementation\n\nFor each problem:\n- Clear problem statement\n- Intuition and approach\n- Recurrence relation\n- Complete working code\n- Time/space complexity\n- 1-2 practice variations"
                    },
                    {
                        title: "DP on Trees",
                        description: "Applying dynamic programming to tree structures and tree problems.",
                        prompt: "Teach me DP on Trees comprehensively:\n1. Why DP on Trees?\n   - Tree structure allows subproblem decomposition\n   - How trees provide optimal substructure\n\n2. Common Patterns:\n   a) Subtree DP:\n      - Compute answer for each subtree\n      - Combine child results\n      - Example: Tree height, tree diameter\n   b) Root-to-Node Path DP:\n      - Maintain state from root\n      - Example: Path sum problems\n\n3. Classic Problems with Complete Solutions:\n   \n   a) House Robber III:\n      - Can't rob two connected nodes\n      - State: (rob_root, dont_rob_root)\n      - Recurrence relation\n      - Complete code\n   \n   b) Binary Tree Maximum Path Sum:\n      - Path can start/end anywhere\n      - How to handle negative values\n      - Implementation\n   \n   c) Diameter of Binary Tree:\n      - Longest path between any two nodes\n      - Solution approach\n      - Code\n   \n   d) Longest Univalue Path:\n      - Path with same values\n      - Implementation\n\n4. DFS + DP Pattern:\n   - Template code structure\n   - When to update global vs return value\n\n5. Re-rooting Technique:\n   - Answer when each node is root\n   - Two-pass approach\n   - Example problem\n\n6. Provide 4 practice problems with hints\nFocus on building intuition for state design."
                    },
                    {
                        title: "DP on Graphs",
                        description: "Using dynamic programming for graph problems and shortest paths.",
                        prompt: "Explain DP on Graphs:\n1. When to use DP vs BFS/DFS?\n   - DAG (Directed Acyclic Graph) - ideal for DP\n   - Why cycles complicate DP\n\n2. DP on DAG:\n   - Topological sort + DP\n   - Longest path in DAG\n   - Complete implementation\n   - Number of paths\n\n3. Shortest Path Algorithms:\n   a) Bellman-Ford (DP-based):\n      - Recurrence relation\n      - Why n-1 iterations?\n      - Negative cycle detection\n      - Implementation\n   \n   b) Floyd-Warshall (All-pairs shortest path):\n      - 3D DP to 2D optimization\n      - dp[i][j][k] meaning\n      - Implementation\n      - Path reconstruction\n      - O(n¬≥) analysis\n\n4. Traveling Salesman Problem (TSP):\n   - Bitmask DP approach\n   - State: dp[mask][current]\n   - Recurrence relation\n   - Complete solution\n   - Time: O(n¬≤ ¬∑ 2‚Åø)\n\n5. Graph Coloring:\n   - Chromatic number using DP\n   - Bitmask representation\n\n6. Other Problems:\n   - Number of ways to reach destination\n   - Cheapest flights with k stops\n   - Network delay time\n\nFor each: problem statement, approach, code, complexity"
                    },
                    {
                        title: "Advanced DP Techniques",
                        description: "Digit DP, bitmask DP, and space optimization techniques.",
                        prompt: "Teach me advanced DP techniques:\n\n1. Bitmask DP:\n   - When to use: small n, need subset state\n   - Bit operations review\n   - Example 1: Traveling Salesman\n     * State representation\n     * Transitions\n     * Complete code\n   - Example 2: Maximum Students (2D grid + bitmask)\n   - Template pattern for bitmask DP\n\n2. Digit DP:\n   - Use case: count numbers with properties\n   - Problem: Count numbers with digit d between L and R\n   - Building the number digit by digit\n   - State: (position, tight_bound, started)\n   - Recursive structure\n   - Memoization strategy\n   - Complete implementation\n   - More examples:\n     * Numbers with unique digits\n     * Sum of digits in range\n\n3. State Compression:\n   - Reducing dimensions\n   - Profile/Broken profile DP\n   - Example: Tiling problems\n\n4. Space Optimization Techniques:\n   - Rolling array (2D ‚Üí 1D)\n   - Example: Edit distance optimized\n   - When dp[i] depends only on dp[i-1]\n   - State reuse patterns\n\n5. DP with Data Structures:\n   - DP + Segment Tree\n   - DP + Fenwick Tree\n   - Use case and example\n\n6. Provide 5 problems:\n   - 2 bitmask DP\n   - 2 digit DP\n   - 1 space optimization challenge"
                    },
                    {
                        title: "DP Optimization",
                        description: "Monotonic queue optimization, divide and conquer DP, and convex hull trick.",
                        prompt: "Teach me DP optimization techniques (advanced):\n\n1. Monotonic Queue/Stack Optimization:\n   - Problem: DP with range min/max queries\n   - Reduces O(nk) to O(n)\n   - Example: Sliding Window Maximum\n   - Application in DP: Jump Game variations\n   - Complete implementation\n\n2. Convex Hull Trick (CHT):\n   - When: DP with linear function optimization\n   - Problem type: dp[i] = min/max(dp[j] + f(i,j))\n   - When f(i,j) is linear\n   - Geometry intuition\n   - Example: Building Bridges\n   - Implementation (both O(n log n) and O(n))\n\n3. Divide and Conquer DP:\n   - Condition: dp[i][j] optimal split point is monotonic\n   - Reduces O(kn¬≤) to O(kn log n)\n   - Example problem\n   - Implementation template\n\n4. Knuth's Optimization:\n   - Condition: quadrangle inequality\n   - O(n¬≥) to O(n¬≤)\n   - Example: Optimal BST\n\n5. Aliens Trick (Lagrange Optimization):\n   - When: fixed k items, minimize cost\n   - Binary search on Lagrange multiplier\n   - Example problem\n\n6. Practical Advice:\n   - How to identify which optimization applies\n   - Decision tree for choosing technique\n   - Common pitfalls\n\nFor each:\n- Mathematical condition\n- Intuitive explanation\n- Template code\n- Example problem\n- When to use\n\nNote: These are competition-level techniques. Master basics first!"
                    }
                ]
            },
            "Bit Manipulation": {
                description: "Techniques for manipulating individual bits in binary representations of data.",
                subtopics: [
                    {
                        title: "Bitwise Operators",
                        description: "AND, OR, XOR, NOT, and shift operators with their properties.",
                        prompt: "Teach me bitwise operators comprehensively:\n1. Binary Number System Review:\n   - Conversion decimal ‚Üî binary\n   - Why bits matter in computing\n2. Bitwise Operators:\n   a) AND (&): both bits 1 ‚Üí 1\n   b) OR (|): any bit 1 ‚Üí 1\n   c) XOR (^): different bits ‚Üí 1\n   d) NOT (~): flip all bits\n   e) Left Shift (<<): multiply by 2\n   f) Right Shift (>>): divide by 2\n3. Truth tables for each\n4. Examples:\n   - 5 & 3 = ?\n   - 5 | 3 = ?\n   - 5 ^ 3 = ?\n5. Properties:\n   - XOR: a^a=0, a^0=a\n   - AND: clear bits\n   - OR: set bits\n6. Provide implementations and practice problems"
                    },
                    {
                        title: "Bit Manipulation Tricks",
                        description: "Common bit manipulation techniques and useful bit patterns.",
                        prompt: "Master bit manipulation tricks:\n1. Check if power of 2: n & (n-1) == 0\n2. Count set bits: Brian Kernighan's algorithm\n3. Get rightmost set bit: n & (-n)\n4. Clear rightmost set bit: n & (n-1)\n5. Toggle bit at position i: n ^ (1<<i)\n6. Set bit at position i: n | (1<<i)\n7. Clear bit at position i: n & ~(1<<i)\n8. Check if bit i is set: (n >> i) & 1\n9. Swap two numbers without temp: using XOR\n10. Find single number in pairs: XOR all\n11. Problems:\n    - Single number\n    - Number of 1 bits\n    - Power of two\n    - Reverse bits\n12. Provide code for all tricks with explanations"
                    },
                    {
                        title: "Bitmasking for Subsets",
                        description: "Using bitmasks to represent and manipulate subsets efficiently.",
                        prompt: "Learn bitmasking for subsets:\n1. Representing Subsets:\n   - Set {a,b,c}: use 3 bits\n   - 101 means {a,c}\n   - All subsets of n elements: 0 to 2^n-1\n2. Generate All Subsets:\n   - Iterate 0 to 2^n-1\n   - Check each bit\n   - Implementation\n3. Subset Operations:\n   - Union: mask1 | mask2\n   - Intersection: mask1 & mask2\n   - Difference: mask1 & (~mask2)\n   - Check if subset: (mask1 & mask2) == mask1\n4. Iterate Over Subsets of Mask:\n   - for (int s=mask; s; s=(s-1)&mask)\n   - Why this works\n5. Applications:\n   - Subset sum with bitmask\n   - Maximum AND value\n6. Provide complete examples and 4 problems"
                    },
                    {
                        title: "Bitmask DP",
                        description: "Using bitmasks in dynamic programming for state representation.",
                        prompt: "This is covered in Dynamic Programming section under 'Advanced DP Techniques'. Refer to that section for comprehensive bitmask DP coverage including TSP and other problems."
                    },
                    {
                        title: "Bit Manipulation Applications",
                        description: "Applications in optimization, cryptography, and competitive programming.",
                        prompt: "Apply bit manipulation:\n1. Problems:\n   - Missing number: XOR technique\n   - Two non-repeating numbers: XOR + grouping\n   - Maximum XOR of two numbers\n   - Count triplets with XOR\n2. Space Optimization:\n   - Store boolean flags in single int\n   - Example: visited array as bitmask\n3. Fast Operations:\n   - Multiply/divide by powers of 2\n   - Check even/odd: n & 1\n4. Competitive Programming:\n   - When to use bit manipulation\n   - Common patterns\n5. Provide 5 complete problem solutions"
                    },
                    {
                        title: "Advanced Bit Techniques",
                        description: "Bit manipulation in advanced algorithms and data structures.",
                        prompt: "Explore advanced bit techniques:\n1. Bit Trie:\n   - For XOR queries\n   - Maximum XOR pair\n   - Implementation\n2. Gray Code:\n   - Adjacent codes differ by 1 bit\n   - Generation\n   - Applications\n3. Bitwise Sieve:\n   - Space-optimized sieve\n   - Store 8 numbers in 1 byte\n4. Bit Tricks in Fenwick Tree:\n   - How i&-i isolates rightmost bit\n   - Why it works\n5. SWAR (SIMD Within A Register):\n   - Parallel bit operations\n   - Concept overview\n6. Focus on practical techniques"
                    }
                ]
            },
            "Number Theory": {
                description: "Mathematical algorithms and techniques for working with integers and number properties.",
                subtopics: [
                    {
                        title: "GCD and LCM",
                        description: "Greatest Common Divisor and Least Common Multiple using Euclidean algorithm.",
                        prompt: "Learn GCD and LCM:\n1. GCD (Greatest Common Divisor):\n   - Definition: largest number dividing both\n   - Euclidean Algorithm:\n     * gcd(a,b) = gcd(b, a mod b)\n     * Base case: gcd(a, 0) = a\n   - Example: gcd(48, 18)\n   - Implementation (recursive and iterative)\n   - Time: O(log min(a,b))\n2. LCM (Least Common Multiple):\n   - Definition: smallest number divisible by both\n   - Formula: lcm(a,b) = (a*b)/gcd(a,b)\n   - Why this works\n   - Implementation\n3. Extended Euclidean Algorithm:\n   - Find x, y such that ax + by = gcd(a,b)\n   - Applications: modular inverse\n   - Implementation\n4. Applications:\n   - Simplifying fractions\n   - Adding fractions\n   - Problems involving cycles\n5. Provide implementations and 3 problems"
                    },
                    {
                        title: "Primality Testing",
                        description: "Algorithms for checking if a number is prime efficiently.",
                        prompt: "Master primality testing:\n1. Trial Division:\n   - Check divisibility up to ‚àön\n   - O(‚àön) time\n   - Implementation\n2. Fermat Primality Test:\n   - If n prime: a^(n-1) ‚â° 1 (mod n)\n   - Probabilistic\n   - Carmichael numbers (false positives)\n3. Miller-Rabin Test:\n   - More reliable probabilistic test\n   - Multiple rounds\n   - Implementation\n   - Error probability\n4. Deterministic Tests:\n   - AKS algorithm (polynomial time)\n   - Concept overview\n5. When to use which test\n6. Provide implementation of Miller-Rabin"
                    },
                    {
                        title: "Sieve Algorithms",
                        description: "Sieve of Eratosthenes and other sieve techniques for finding primes.",
                        prompt: "Learn sieve algorithms:\n1. Sieve of Eratosthenes:\n   - Find all primes up to n\n   - Mark multiples of each prime\n   - Algorithm steps\n   - Implementation\n   - Time: O(n log log n)\n   - Space: O(n)\n2. Optimizations:\n   - Start from p¬≤\n   - Only check odd numbers\n   - Bit optimization\n3. Segmented Sieve:\n   - For large ranges\n   - Memory efficient\n   - Concept\n4. Applications:\n   - Count primes\n   - Prime factorization preprocessing\n5. Provide complete implementation"
                    },
                    {
                        title: "Prime Factorization",
                        description: "Algorithms for decomposing numbers into prime factors.",
                        prompt: "Learn prime factorization:\n1. Trial Division:\n   - Divide by primes up to ‚àön\n   - O(‚àön) time\n   - Implementation\n2. Using Sieve:\n   - Precompute smallest prime factor\n   - O(log n) factorization\n   - Implementation\n3. Pollard's Rho Algorithm:\n   - For large numbers\n   - Probabilistic\n   - Concept overview\n4. Applications:\n   - Finding divisors\n   - Euler's totient\n   - GCD/LCM\n5. Provide implementations and problems"
                    },
                    {
                        title: "Modular Arithmetic",
                        description: "Arithmetic operations under modular arithmetic with applications.",
                        prompt: "Master modular arithmetic:\n1. Basic Operations:\n   - (a+b) mod m = ((a mod m) + (b mod m)) mod m\n   - Same for subtraction, multiplication\n   - Prevent overflow\n2. Modular Exponentiation:\n   - Compute a^b mod m efficiently\n   - Binary exponentiation\n   - O(log b) time\n   - Implementation\n3. Modular Inverse:\n   - a * a^(-1) ‚â° 1 (mod m)\n   - Using Extended Euclidean\n   - Using Fermat's (if m prime)\n   - Implementation\n4. Modular Division:\n   - a/b mod m = a * b^(-1) mod m\n5. Applications:\n   - Large number calculations\n   - Cryptography\n   - Combinatorics\n6. Problems with mod 10^9+7\n7. Provide complete implementations"
                    },
                    {
                        title: "Advanced Number Theory",
                        description: "Chinese Remainder Theorem, Fermat's Little Theorem, and Euler's Totient.",
                        prompt: "Learn advanced number theory:\n1. Fermat's Little Theorem:\n   - If p prime: a^(p-1) ‚â° 1 (mod p)\n   - Application: modular inverse\n   - a^(-1) ‚â° a^(p-2) (mod p)\n2. Euler's Totient Function œÜ(n):\n   - Count of numbers ‚â§ n coprime to n\n   - Formula using prime factorization\n   - Implementation\n   - Euler's Theorem: a^œÜ(n) ‚â° 1 (mod n)\n3. Chinese Remainder Theorem (CRT):\n   - System of modular equations\n   - When moduli are coprime\n   - Algorithm\n   - Implementation\n4. Wilson's Theorem:\n   - (p-1)! ‚â° -1 (mod p) for prime p\n5. Applications in competitive programming\n6. Provide implementations for Totient and CRT"
                    }
                ]
            },
            "Computational Geometry": {
                description: "Algorithms for solving geometric problems and working with geometric objects.",
                subtopics: [
                    {
                        title: "Convex Hull Algorithms",
                        description: "Graham scan, Jarvis march, and Andrew's monotone chain algorithms.",
                        prompt: "Learn convex hull algorithms (advanced geometry):\n1. What is Convex Hull?\n   - Smallest convex polygon containing all points\n   - Real-world: gift wrapping analogy\n2. Graham Scan:\n   - Sort points by polar angle\n   - Stack-based approach\n   - O(n log n)\n   - Implementation outline\n3. Jarvis March (Gift Wrapping):\n   - Start from leftmost point\n   - Find next point with smallest angle\n   - O(nh) where h is hull size\n4. Andrew's Monotone Chain:\n   - Sort by x-coordinate\n   - Build lower and upper hulls\n   - O(n log n)\n   - Simplest to implement\n5. Cross Product:\n   - Determining left/right turn\n   - Implementation\n6. Provide Andrew's algorithm implementation\nNote: Specialized topic for competitive programming"
                    },
                    {
                        title: "Line Segment Intersection",
                        description: "Algorithms for finding intersections between line segments.",
                        prompt: "Learn line segment intersection:\n1. Basic Geometry:\n   - Point, line segment representation\n   - Distance, slope calculations\n2. Do Two Segments Intersect?\n   - Orientation test (CCW)\n   - Special cases: collinear, endpoints\n   - Implementation\n3. Sweep Line Algorithm:\n   - For n segments, find all intersections\n   - Event point approach\n   - O((n+k) log n) where k is intersections\n   - Concept overview\n4. Applications:\n   - Computer graphics\n   - Map overlays\n5. Provide intersection check implementation"
                    },
                    {
                        title: "Closest Pair of Points",
                        description: "Divide and conquer algorithm for finding the closest pair of points.",
                        prompt: "Learn closest pair of points:\n1. Problem: find two points with minimum distance\n2. Brute Force: O(n¬≤)\n3. Divide and Conquer:\n   - Sort by x-coordinate\n   - Divide into two halves\n   - Recursively find closest in each\n   - Check points near dividing line\n   - O(n log n)\n   - Why it works\n4. Implementation outline\n5. Applications in clustering"
                    },
                    {
                        title: "Geometric Properties",
                        description: "Calculating area, perimeter, and other properties of geometric shapes.",
                        prompt: "Learn geometric calculations:\n1. Area of Polygon:\n   - Shoelace formula\n   - Sum of cross products\n   - Implementation\n2. Perimeter: sum of edge lengths\n3. Point in Polygon:\n   - Ray casting algorithm\n   - Count intersections\n   - Implementation\n4. Convexity Check:\n   - All turns same direction\n5. Distance between point and line\n6. Provide implementations for area and point-in-polygon"
                    },
                    {
                        title: "Sweep Line Algorithms",
                        description: "Using sweep line technique for geometric problems.",
                        prompt: "Learn sweep line technique:\n1. Concept:\n   - Imaginary line sweeps across plane\n   - Process events in order\n   - Maintain active elements\n2. Applications:\n   - Line segment intersection\n   - Rectangle union area\n   - Closest pair\n3. Event-driven approach\n4. Data structures: priority queue, balanced BST\n5. Example: Rectangle area union\n6. High-level overview\nNote: Advanced technique for specific problems"
                    },
                    {
                        title: "Geometric Applications",
                        description: "Applications in graphics, GIS, robotics, and computer vision.",
                        prompt: "Explore geometry applications:\n1. Computer Graphics:\n   - Rendering, clipping\n   - Collision detection\n2. GIS (Geographic Information Systems):\n   - Map overlays\n   - Spatial queries\n3. Robotics:\n   - Path planning\n   - Obstacle avoidance\n4. Computer Vision:\n   - Object recognition\n   - Shape matching\n5. CAD/CAM systems\n6. Common problems:\n   - K closest points\n   - Points in rectangle\n   - Intersection of rectangles\n7. Focus on practical applications"
                    }
                ]
            },
            "Advanced Data Structures": {
                description: "Sophisticated data structures for specialized applications and optimization.",
                subtopics: [
                    {
                        title: "Segment Trees with Lazy Propagation",
                        description: "Advanced segment trees with lazy updates for range operations.",
                        prompt: "This is thoroughly covered in the Trees section under 'Segment Trees'. Please refer to that section for complete coverage of lazy propagation, range updates, and applications."
                    },
                    {
                        title: "Persistent Data Structures",
                        description: "Data structures that maintain multiple versions efficiently.",
                        prompt: "Learn persistent data structures (advanced):\n1. What is Persistence?\n   - Keep all versions after modifications\n   - Path copying technique\n2. Persistent Segment Tree:\n   - Only O(log n) new nodes per update\n   - Applications: kth smallest in range\n   - Concept overview\n3. Persistent Arrays:\n   - Implement using trees\n4. When to use: version control, time travel queries\n5. Focus on concept over implementation"
                    },
                    {
                        title: "Disjoint Set Union (Union-Find)",
                        description: "Data structure for managing disjoint sets with union and find operations.",
                        prompt: "This is covered in the Graphs section under 'Minimum Spanning Tree'. Refer there for complete Union-Find coverage with path compression and union by rank."
                    },
                    {
                        title: "Advanced Tree Structures",
                        description: "Treap, Splay tree, and other self-balancing tree structures.",
                        prompt: "This is covered in the Trees section under 'Balanced Trees'. Refer there for Treap, Splay trees, and other self-balancing structures."
                    },
                    {
                        title: "Suffix Trees and Arrays",
                        description: "Advanced string data structures for efficient string operations.",
                        prompt: "This is covered in the Strings section under 'Suffix Arrays and Suffix Trees'. Refer there for comprehensive coverage."
                    },
                    {
                        title: "Range Query Data Structures",
                        description: "Specialized structures for efficient range queries and updates.",
                        prompt: "This is covered in the Trees section under 'Segment Trees' and 'Fenwick Trees'. Refer there for complete range query data structure coverage."
                    }
                ]
            },
            "Advanced Graph Algorithms": {
                description: "Sophisticated graph algorithms for complex graph problems and optimization.",
                subtopics: [
                    {
                        title: "Network Flow Algorithms",
                        description: "Ford-Fulkerson, Edmonds-Karp, and Dinic's algorithms for maximum flow.",
                        prompt: "This is covered in the Graphs section under 'Network Flow'. Refer there for complete coverage of flow algorithms."
                    },
                    {
                        title: "Minimum Cost Flow",
                        description: "Algorithms for finding minimum cost flows in networks.",
                        prompt: "Learn min-cost flow (advanced):\n1. Problem: maximize flow while minimizing cost\n2. Applications: assignment with costs\n3. Algorithms: cycle-canceling, successive shortest path\n4. High-level concept\n5. Reference: specialized optimization topic"
                    },
                    {
                        title: "Bipartite Matching",
                        description: "Algorithms for maximum matching in bipartite graphs.",
                        prompt: "This is covered in the Graphs section under 'Network Flow' and 'Advanced Graph Algorithms'. Refer there for bipartite matching."
                    },
                    {
                        title: "Advanced Shortest Paths",
                        description: "Johnson's algorithm, A* algorithm, and k-shortest paths.",
                        prompt: "This is covered in the Graphs section under 'Advanced Graph Algorithms'. Refer there for A* and Johnson's algorithm."
                    },
                    {
                        title: "Eulerian and Hamiltonian Paths",
                        description: "Algorithms for finding Eulerian and Hamiltonian paths and cycles.",
                        prompt: "This is covered in the Graphs section under 'Advanced Graph Algorithms'. Refer there for complete coverage."
                    },
                    {
                        title: "Graph Connectivity",
                        description: "Finding articulation points, bridges, and biconnected components.",
                        prompt: "This is covered in the Graphs section under 'Connected Components'. Refer there for complete connectivity algorithm coverage."
                    }
                ]
            },
            "Advanced Tree Algorithms": {
                description: "Sophisticated algorithms for tree structures and tree-based problems.",
                subtopics: [
                    {
                        title: "Heavy-Light Decomposition",
                        description: "Technique for decomposing trees into chains for efficient queries.",
                        prompt: "This is covered in the Trees section under 'Advanced Tree Algorithms'. Refer there for complete HLD coverage."
                    },
                    {
                        title: "Centroid Decomposition",
                        description: "Tree decomposition technique using centroids for divide and conquer.",
                        prompt: "This is covered in the Trees section under 'Advanced Tree Algorithms'. Refer there for complete centroid decomposition coverage."
                    },
                    {
                        title: "Lowest Common Ancestor (LCA)",
                        description: "Algorithms for finding LCA using binary lifting and other techniques.",
                        prompt: "This is covered in the Trees section under 'Advanced Tree Algorithms'. Refer there for complete LCA coverage with binary lifting."
                    },
                    {
                        title: "Tree DP",
                        description: "Dynamic programming on trees for solving tree-based optimization problems.",
                        prompt: "This is covered in the Dynamic Programming section under 'DP on Trees'. Refer there for comprehensive tree DP coverage."
                    },
                    {
                        title: "Tree Queries",
                        description: "Handling various types of queries on tree structures efficiently.",
                        prompt: "This is covered in the Trees section under 'Advanced Tree Algorithms'. Refer there for tree query techniques."
                    },
                    {
                        title: "Advanced Tree Problems",
                        description: "Complex tree problems requiring advanced techniques and algorithms.",
                        prompt: "This combines multiple tree techniques covered in Trees, Graphs, and DP sections. Review those sections for comprehensive tree problem-solving skills."
                    }
                ]
            },
            "Advanced String Algorithms": {
                description: "Sophisticated algorithms for complex string processing and pattern matching.",
                subtopics: [
                    {
                        title: "Advanced Pattern Matching",
                        description: "KMP, Z-algorithm, and Rabin-Karp with optimizations and variations.",
                        prompt: "This is covered in the Strings section under 'Pattern Matching Algorithms'. Refer there for complete coverage."
                    },
                    {
                        title: "Suffix Arrays and Trees",
                        description: "Advanced string data structures for efficient string operations.",
                        prompt: "This is covered in the Strings section under 'Suffix Arrays and Suffix Trees'. Refer there for complete coverage."
                    },
                    {
                        title: "String Hashing Techniques",
                        description: "Advanced hashing techniques for strings and text processing.",
                        prompt: "This is covered in the Strings section under 'String Hashing'. Refer there for comprehensive string hashing coverage."
                    },
                    {
                        title: "Palindromic Tree (Eertree)",
                        description: "Specialized tree structure for palindrome-related problems.",
                        prompt: "This is covered in the Strings section under 'Palindrome Problems' with mentions of Eertree. Refer there."
                    },
                    {
                        title: "String Compression",
                        description: "Algorithms for string compression and decompression.",
                        prompt: "Learn string compression:\n1. Huffman Coding:\n   - Frequency-based encoding\n   - Build tree, generate codes\n   - Variable-length codes\n   - Implementation overview\n2. Lempel-Ziv (LZ77, LZ78):\n   - Dictionary-based compression\n   - Used in ZIP, GIF\n   - Concept\n3. Run-length encoding\n4. Applications: file compression, data transmission"
                    },
                    {
                        title: "Bioinformatics Applications",
                        description: "String algorithms in bioinformatics and DNA sequence analysis.",
                        prompt: "String algorithms in bioinformatics:\n1. DNA Sequence Alignment:\n   - Edit distance\n   - Smith-Waterman algorithm\n   - Needleman-Wunsch algorithm\n2. Pattern Matching in Genomes:\n   - Finding genes\n   - Using suffix trees/arrays\n3. Longest Common Subsequence:\n   - Comparing DNA sequences\n4. Applications in genomics, proteomics\n5. High-level overview of specialized field"
                    }
                ]
            },
            "Probabilistic & Randomized Algorithms": {
                description: "Algorithms that use randomness to solve problems efficiently.",
                subtopics: [
                    {
                        title: "Monte Carlo Algorithms",
                        description: "Randomized algorithms that may produce incorrect results with known probability.",
                        prompt: "Learn Monte Carlo algorithms:\n1. Definition: may give wrong answer with probability Œµ\n2. Examples:\n   - Randomized primality testing\n   - Approximate counting\n3. Running multiple times reduces error\n4. When to use: approximate solutions acceptable\n5. Example: Karger's min-cut algorithm"
                    },
                    {
                        title: "Las Vegas Algorithms",
                        description: "Randomized algorithms that always produce correct results but with random running time.",
                        prompt: "Learn Las Vegas algorithms:\n1. Definition: always correct, random running time\n2. Examples:\n   - Randomized quicksort\n   - Randomized quickselect\n3. Expected time analysis\n4. When to use: correctness required\n5. Compare with deterministic algorithms"
                    },
                    {
                        title: "Randomized Sorting",
                        description: "Randomized versions of sorting algorithms like randomized quicksort.",
                        prompt: "This is covered in Searching & Sorting section. Randomized quicksort is explained there with expected O(n log n) performance."
                    },
                    {
                        title: "Randomized Primality Testing",
                        description: "Probabilistic methods for testing primality of large numbers.",
                        prompt: "This is covered in Number Theory section under 'Primality Testing'. Refer there for Miller-Rabin and other tests."
                    },
                    {
                        title: "Randomized Data Structures",
                        description: "Data structures that use randomization for efficiency.",
                        prompt: "Learn randomized data structures:\n1. Skip List:\n   - Randomized levels\n   - Expected O(log n) operations\n   - Alternative to balanced trees\n   - Concept and applications\n2. Treap:\n   - Random priorities\n   - Covered in Trees section\n3. Bloom Filter:\n   - Probabilistic set membership\n   - Covered in Hashing section"
                    },
                    {
                        title: "Applications in Cryptography",
                        description: "Using randomized algorithms in cryptographic applications.",
                        prompt: "Randomness in cryptography:\n1. Random Number Generation:\n   - Cryptographically secure RNG\n   - Importance in security\n2. Key Generation:\n   - RSA, AES keys\n3. Randomized protocols:\n   - Zero-knowledge proofs\n   - Secure multi-party computation\n4. High-level overview of specialized field"
                    }
                ]
            },
            "Game Theory Algorithms": {
                description: "Algorithms for analyzing strategic decision-making in games and competitions.",
                subtopics: [
                    {
                        title: "Minimax Algorithm",
                        description: "Algorithm for finding optimal moves in two-player zero-sum games.",
                        prompt: "Learn minimax algorithm:\n1. Two-player zero-sum games:\n   - One player's gain = other's loss\n2. Game tree:\n   - Nodes are game states\n   - Edges are moves\n3. Minimax principle:\n   - Maximize your score\n   - Assume opponent minimizes\n4. Recursive algorithm\n5. Example: Tic-tac-toe\n6. Implementation outline\n7. Time: O(b^d) where b=branching, d=depth"
                    },
                    {
                        title: "Alpha-Beta Pruning",
                        description: "Optimization technique for minimax algorithm to reduce search space.",
                        prompt: "Learn alpha-beta pruning:\n1. Optimization for minimax\n2. Track alpha (best for MAX) and beta (best for MIN)\n3. Prune branches that won't affect result\n4. Example walkthrough\n5. Best case: O(b^(d/2))\n6. Move ordering matters\n7. Implementation\n8. Used in chess engines"
                    },
                    {
                        title: "Grundy Numbers",
                        description: "Mathematical concept for analyzing impartial games and Nim games.",
                        prompt: "Learn Grundy numbers (Nim-values):\n1. Impartial games: both players same moves\n2. Grundy number G(position):\n   - Minimum excludant (mex) of reachable positions\n3. Winning strategy: G(pos) != 0\n4. Computing Grundy numbers\n5. Combining games: XOR of Grundy numbers\n6. Applications in competitive programming"
                    },
                    {
                        title: "Nim Game",
                        description: "Classic mathematical game and its variations with winning strategies.",
                        prompt: "Learn Nim game:\n1. Game: piles of stones, remove any number from one pile\n2. Losing position: all piles empty\n3. Winning strategy: XOR of pile sizes != 0\n4. Why XOR works (proof sketch)\n5. Variations:\n   - Mis√®re Nim\n   - Nim with constraints\n6. Implementation\n7. Problems using Nim concept"
                    },
                    {
                        title: "Two-Player Games",
                        description: "Algorithms for analyzing various two-player games and finding optimal strategies.",
                        prompt: "Analyze two-player games:\n1. Game types:\n   - Perfect information vs imperfect\n   - Deterministic vs stochastic\n2. Solving games:\n   - Minimax for perfect information\n   - DP for small state space\n3. Examples:\n   - Tic-tac-toe\n   - Connect-4\n   - Chess endgames\n4. Nim-like games\n5. Focus on algorithmic approaches"
                    },
                    {
                        title: "Applications in AI",
                        description: "Using game theory algorithms in artificial intelligence and machine learning.",
                        prompt: "Game theory in AI:\n1. Game-playing AI:\n   - Chess, Go, poker engines\n   - Deep learning + search\n2. Multi-agent systems:\n   - Nash equilibrium\n   - Coordination games\n3. Reinforcement learning:\n   - Game as environment\n4. Adversarial training:\n   - GANs\n5. High-level overview"
                    }
                ]
            },
            "Miscellaneous & Patterns": {
                description: "Common algorithmic patterns and techniques used across different problem domains.",
                subtopics: [
                    {
                        title: "Two Pointer Technique",
                        description: "Efficient algorithm pattern using two pointers to solve array and string problems.",
                        prompt: "This is comprehensively covered in the Arrays section under 'Two Pointer Technique'. Refer there for complete coverage."
                    },
                    {
                        title: "Sliding Window Technique",
                        description: "Optimized approach for solving subarray and substring problems.",
                        prompt: "This is comprehensively covered in the Arrays section under 'Sliding Window Technique'. Refer there for complete coverage."
                    },
                    {
                        title: "Divide and Conquer",
                        description: "Problem-solving paradigm that breaks problems into smaller subproblems.",
                        prompt: "Learn divide and conquer paradigm:\n1. Three steps:\n   - Divide: break into subproblems\n   - Conquer: solve recursively\n   - Combine: merge solutions\n2. Classic examples:\n   - Merge sort\n   - Binary search\n   - Closest pair of points\n   - Karatsuba multiplication\n3. Master theorem for complexity\n4. When to use: subproblems are similar\n5. Covered in detail in Recursion, Sorting, and other sections"
                    },
                    {
                        title: "Greedy Algorithms",
                        description: "Algorithms that make locally optimal choices at each step.",
                        prompt: "Master greedy algorithms:\n1. Greedy choice property:\n   - Local optimum leads to global optimum\n2. When greedy works:\n   - Optimal substructure\n   - Greedy choice property\n3. Proving correctness:\n   - Exchange argument\n   - Contradiction\n4. Classic problems:\n   - Activity selection\n   - Huffman coding\n   - Fractional knapsack\n   - Minimum spanning tree (Kruskal, Prim)\n5. When greedy fails:\n   - 0/1 knapsack\n   - Need DP instead\n6. Provide 5 greedy problem solutions"
                    },
                    {
                        title: "Meet-in-the-Middle",
                        description: "Technique for reducing exponential time complexity by splitting problems.",
                        prompt: "Learn meet-in-the-middle:\n1. Idea: split search space in half\n2. Solve both halves, combine results\n3. Reduces O(2^n) to O(2^(n/2))\n4. Example: Subset sum\n   - Generate all sums of first half\n   - For each sum in second half, find complement\n   - O(2^(n/2) log(2^(n/2)))\n5. Example: Four sum\n6. When to use: exponential but n is small (n ‚â§ 40)\n7. Provide implementation and 2 problems"
                    },
                    {
                        title: "Optimization Techniques",
                        description: "Space and time optimization tricks for improving algorithm efficiency.",
                        prompt: "Learn optimization techniques:\n1. Space-Time Tradeoffs:\n   - Precomputation\n   - Caching/memoization\n   - Example: Fibonacci\n2. Space Optimization:\n   - Rolling arrays in DP\n   - In-place algorithms\n   - Bit manipulation for flags\n3. Time Optimization:\n   - Early termination\n   - Pruning in backtracking\n   - Better data structures\n4. Constant factor optimization:\n   - Loop unrolling\n   - Avoiding divisions\n5. When to optimize and when not to\n6. Provide before/after examples"
                    },
                    {
                        title: "Problem-Solving Patterns",
                        description: "Common patterns like prefix sums, difference arrays, and monotonic structures.",
                        prompt: "Master problem-solving patterns:\n1. Prefix Sum: covered in Arrays section\n2. Difference Array: covered in Arrays section\n3. Monotonic Stack: covered in Stacks section\n4. Monotonic Queue/Deque: covered in Queues section\n5. Binary Search on Answer: covered in Searching section\n6. Frequency Counting: hash map pattern\n7. Runner technique: fast/slow pointers\n8. In-place array manipulation\n9. Transform and conquer\n10. Pattern recognition guide:\n    - Input characteristics\n    - What pattern applies\n11. Provide pattern matching decision tree"
                    }
                ]
            }
        };

        // Helper function to escape CSS selectors
        function escapeCSS(str) {
            return CSS.escape ? CSS.escape(str) : str.replace(/[^\w-]/g, '\\$&');
        }

        // Initialize the application
        function initializeApp() {
            createNavigationTabs();
            createTopicSections();
            setupSearchFunctionality();
            setupCopyFunctionality();
            showTopic('Arrays'); // Show first topic by default
        }

        // Create navigation tabs
        function createNavigationTabs() {
            const navTabs = document.getElementById('navTabs');
            if (!navTabs) return; // Safety check
            
            Object.keys(dsaData).forEach((topic, index) => {
                const tab = document.createElement('button');
                tab.className = 'nav-tab';
                tab.textContent = topic;
                tab.onclick = () => showTopic(topic);
                if (index === 0) tab.classList.add('active');
                navTabs.appendChild(tab);
            });
        }

        // Create topic sections
        function createTopicSections() {
            const topicSections = document.getElementById('topicSections');
            if (!topicSections) return; // Safety check
            
            Object.keys(dsaData).forEach(topic => {
                const section = document.createElement('div');
                section.className = 'topic-section';
                section.id = `topic-${topic}`;
                
                const data = dsaData[topic];
                section.innerHTML = `
                    <div class="topic-header">
                        <h2 class="topic-title">${topic}</h2>
                        <p class="topic-description">${data.description}</p>
                    </div>
                    <div class="subtopics-grid">
                        ${data.subtopics.map(subtopic => `
                            <div class="subtopic-card">
                                <h3 class="subtopic-title">${subtopic.title}</h3>
                                <p class="subtopic-description">${subtopic.description}</p>
                                <div class="prompt-box" onclick="copyToClipboard(this)">
                                    <button class="copy-btn">Copy</button>
                                    ${subtopic.prompt}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
                topicSections.appendChild(section);
            });
        }

        // Show specific topic
        function showTopic(topicName) {
            // Update active tab
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            const tabIndex = Object.keys(dsaData).indexOf(topicName);
            if (tabIndex !== -1) {
                const activeTab = document.querySelector(`.nav-tab:nth-child(${tabIndex + 1})`);
                if (activeTab) activeTab.classList.add('active');
            }

            // Show topic section
            document.querySelectorAll('.topic-section').forEach(section => {
                section.classList.remove('active');
            });
            const topicSection = document.getElementById(`topic-${topicName}`);
            if (topicSection) {
                topicSection.classList.add('active');
            }
        }

        // Setup search functionality
        function setupSearchFunctionality() {
            const searchBox = document.getElementById('searchBox');
            if (!searchBox) return; // Safety check
            
            searchBox.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase();
                
                if (searchTerm === '') {
                    // Clear search mode - remove inline styles and restore normal tab behavior
                    document.querySelectorAll('.topic-section').forEach(section => {
                        section.style.display = '';
                        section.classList.remove('search-visible');
                    });
                    document.querySelectorAll('.subtopic-card').forEach(card => {
                        card.style.display = '';
                    });
                    // Show the currently active topic
                    const activeTab = document.querySelector('.nav-tab.active');
                    if (activeTab) {
                        showTopic(activeTab.textContent);
                    }
                    return;
                }

                // Search mode - show all matching topics and subtopics
                Object.keys(dsaData).forEach(topic => {
                    const topicData = dsaData[topic];
                    const topicMatches = topic.toLowerCase().includes(searchTerm) || 
                                       topicData.description.toLowerCase().includes(searchTerm);
                    
                    let hasSubtopicMatch = false;
                    const topicId = `topic-${topic}`;
                    const topicSection = document.getElementById(topicId);
                    
                    if (!topicSection) return; // Safety check
                    
                    topicData.subtopics.forEach((subtopic, index) => {
                        const subtopicMatches = subtopic.title.toLowerCase().includes(searchTerm) ||
                                              subtopic.description.toLowerCase().includes(searchTerm) ||
                                              subtopic.prompt.toLowerCase().includes(searchTerm);
                        
                        // Use direct child selection instead of querySelector to avoid CSS escaping issues
                        const cards = topicSection.querySelectorAll('.subtopic-card');
                        const card = cards[index];
                        
                        if (card) {
                            card.style.display = subtopicMatches ? 'block' : 'none';
                            if (subtopicMatches) hasSubtopicMatch = true;
                        }
                    });

                    if (topicMatches || hasSubtopicMatch) {
                        topicSection.style.display = 'block';
                        topicSection.classList.add('active', 'search-visible');
                    } else {
                        topicSection.style.display = 'none';
                        topicSection.classList.remove('search-visible');
                    }
                });
            });
        }

        // Setup copy functionality
        function setupCopyFunctionality() {
            window.copyToClipboard = function(element) {
                const btn = element.querySelector('.copy-btn');
                if (!btn) return;
                
                const text = element.textContent.replace('Copy', '').trim();
                
                if (!navigator.clipboard) {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    textArea.style.position = 'fixed';
                    textArea.style.opacity = '0';
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        showCopySuccess(btn);
                    } catch (err) {
                        console.error('Copy failed:', err);
                    }
                    document.body.removeChild(textArea);
                    return;
                }
                
                navigator.clipboard.writeText(text).then(() => {
                    showCopySuccess(btn);
                }).catch(err => {
                    console.error('Copy failed:', err);
                });
            };
            
            function showCopySuccess(btn) {
                const originalText = btn.textContent;
                const originalBg = btn.style.background;
                btn.textContent = 'Copied!';
                btn.style.background = 'var(--success)';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = originalBg || '';
                }, 2000);
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
