<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Ultimate DSA Learning Guide</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #818cf8;
            --secondary: #8b5cf6;
            --accent: #ec4899;
            --dark: #0f172a;
            --dark-light: #1e293b;
            --gray: #64748b;
            --gray-light: #cbd5e1;
            --gray-lighter: #f1f5f9;
            --success: #10b981;
            --shadow: rgba(99, 102, 241, 0.15);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            line-height: 1.6;
            color: var(--dark);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 50px;
            padding: 60px 20px 40px;
            animation: slideDown 0.8s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .header h1 {
            font-size: 3.5rem;
            font-weight: 800;
            margin-bottom: 15px;
            text-shadow: 0 4px 20px rgba(0,0,0,0.2);
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, #ffffff 0%, #e0e7ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.25rem;
            opacity: 0.95;
            font-weight: 400;
            letter-spacing: 0.01em;
        }

        .search-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 35px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            border: 1px solid rgba(255, 255, 255, 0.5);
            animation: fadeInUp 0.8s ease-out 0.2s both;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .search-box {
            width: 100%;
            padding: 18px 24px;
            border: 2px solid var(--gray-lighter);
            border-radius: 14px;
            font-size: 1.05rem;
            font-family: 'Inter', sans-serif;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: white;
        }

        .search-box:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 4px var(--shadow), 0 8px 20px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .search-box::placeholder {
            color: var(--gray);
        }

        .nav-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 40px;
            justify-content: center;
            animation: fadeInUp 0.8s ease-out 0.3s both;
        }

        .nav-tab {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 14px 28px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            position: relative;
            overflow: hidden;
        }

        .nav-tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .nav-tab:hover::before {
            left: 100%;
        }

        .nav-tab:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .nav-tab.active {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border-color: transparent;
            box-shadow: 0 8px 30px var(--shadow);
        }

        .topic-section {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 45px;
            margin-bottom: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.12);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .topic-section.active {
            display: block;
            animation: fadeInScale 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes fadeInScale {
            from { 
                opacity: 0; 
                transform: scale(0.95) translateY(20px);
            }
            to { 
                opacity: 1; 
                transform: scale(1) translateY(0);
            }
        }

        .topic-header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 30px;
            position: relative;
        }

        .topic-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 2px;
        }

        .topic-title {
            font-size: 3rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary), var(--secondary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            letter-spacing: -0.02em;
        }

        .topic-description {
            font-size: 1.15rem;
            color: var(--gray);
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.7;
            font-weight: 400;
        }

        .subtopics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }

        .subtopic-card {
            background: white;
            border-radius: 16px;
            padding: 30px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            border: 1px solid var(--gray-lighter);
            box-shadow: 0 4px 20px rgba(0,0,0,0.04);
        }

        .subtopic-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--secondary), var(--accent));
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .subtopic-card:hover::before {
            transform: scaleX(1);
        }

        .subtopic-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.12);
            border-color: var(--primary-light);
        }

        .subtopic-title {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--dark);
            margin-bottom: 15px;
            letter-spacing: -0.01em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .subtopic-title::before {
            content: '‚óè';
            color: var(--primary);
            font-size: 0.6em;
        }

        .subtopic-description {
            color: var(--gray);
            margin-bottom: 24px;
            line-height: 1.7;
            font-size: 0.98rem;
        }

        .prompt-box {
            background: linear-gradient(135deg, var(--dark) 0%, var(--dark-light) 100%);
            color: #e2e8f0;
            padding: 24px;
            border-radius: 12px;
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            position: relative;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
        }

        .prompt-box:hover {
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
            transform: scale(1.01);
            box-shadow: 0 8px 24px rgba(0,0,0,0.2), inset 0 1px 2px rgba(0,0,0,0.2);
        }

        .prompt-box::before {
            content: 'üí°';
            position: absolute;
            top: 14px;
            right: 18px;
            font-size: 1.3rem;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        .copy-btn {
            position: absolute;
            top: 14px;
            right: 50px;
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 14px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }

        .prompt-box:hover .copy-btn {
            opacity: 1;
        }

        .copy-btn:hover {
            background: var(--primary-dark);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }

        .copy-btn:active {
            transform: scale(0.95);
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 50px;
            margin-top: 60px;
            flex-wrap: wrap;
            animation: fadeInUp 0.8s ease-out 0.4s both;
        }

        .stat-item {
            text-align: center;
            color: white;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 30px 50px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .stat-item:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: 800;
            display: block;
            background: linear-gradient(135deg, #ffffff 0%, #e0e7ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            font-size: 1rem;
            opacity: 0.9;
            font-weight: 500;
            margin-top: 5px;
        }

        .footer {
            text-align: center;
            color: white;
            margin-top: 60px;
            padding: 40px 0;
            opacity: 0.85;
            font-weight: 400;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            border: 2px solid transparent;
            background-clip: padding-box;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
            background-clip: padding-box;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header p {
                font-size: 1rem;
            }
            
            .topic-title {
                font-size: 2.2rem;
            }
            
            .subtopics-grid {
                grid-template-columns: 1fr;
            }
            
            .nav-tabs {
                flex-direction: column;
                align-items: stretch;
                padding: 0 20px;
            }
            
            .nav-tab {
                width: 100%;
            }

            .topic-section {
                padding: 25px;
            }

            .stats {
                gap: 25px;
            }

            .stat-item {
                padding: 20px 35px;
            }
        }

        .highlight {
            background: linear-gradient(120deg, #a8edea 0%, #fed6e3 100%);
            padding: 2px 8px;
            border-radius: 6px;
            font-weight: 600;
        }

        /* Loading animation for smooth transitions */
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.8;
            }
        }

        .loading {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ The Ultimate DSA Learning Guide</h1>
            <p>Master Data Structures and Algorithms with AI-Powered Learning Prompts</p>
        </div>

        <div class="search-container">
            <input type="text" class="search-box" id="searchBox" placeholder="üîç Search topics, subtopics, or keywords...">
        </div>

        <div class="nav-tabs" id="navTabs">
            <!-- Navigation tabs will be populated by JavaScript -->
        </div>

        <div id="topicSections">
            <!-- Topic sections will be populated by JavaScript -->
        </div>

        <div class="stats">
            <div class="stat-item">
                <span class="stat-number">22</span>
                <span class="stat-label">Main Topics</span>
            </div>
            <div class="stat-item">
                <span class="stat-number">150+</span>
                <span class="stat-label">Subtopics</span>
            </div>
            <div class="stat-item">
                <span class="stat-number">200+</span>
                <span class="stat-label">LLM Prompts</span>
            </div>
        </div>

        <div class="footer">
            <p>¬© 2024 The Ultimate DSA Learning Guide | Master algorithms with AI assistance</p>
        </div>
    </div>

    <script>
        const dsaData = {
            "Arrays": {
                description: "Fundamental linear data structure for storing elements in contiguous memory locations.",
                subtopics: [
                    {
                        title: "1D and 2D Arrays",
                        description: "Understanding single and multi-dimensional array structures and their memory layout.",
                        prompt: "Teach me about 1D and 2D arrays in DSA, including their memory representation, indexing, and how to declare and initialize them in different programming languages with examples."
                    },
                    {
                        title: "Array Operations",
                        description: "Core operations: insertion, deletion, traversal, searching, and updating elements.",
                        prompt: "Explain all fundamental array operations including insertion, deletion, traversal, searching, and updating elements. Show me the time and space complexities for each operation with code examples."
                    },
                    {
                        title: "Two Pointer Technique",
                        description: "Efficient algorithm pattern using two pointers to solve array problems.",
                        prompt: "Teach me the two pointer technique for arrays, including when to use it, common patterns like opposite direction pointers and same direction pointers, with multiple problem examples and solutions."
                    },
                    {
                        title: "Sliding Window Technique",
                        description: "Optimized approach for solving subarray and substring problems.",
                        prompt: "Explain the sliding window technique for arrays, covering both fixed-size and variable-size windows, with step-by-step examples of problems like maximum sum subarray and longest substring without repeating characters."
                    },
                    {
                        title: "Prefix Sums and Difference Arrays",
                        description: "Preprocessing techniques for efficient range queries and updates.",
                        prompt: "Teach me about prefix sums and difference arrays, including how to implement them, their applications in range queries, and how they optimize time complexity from O(n) to O(1) for certain operations."
                    },
                    {
                        title: "Array Applications",
                        description: "Real-world applications in sorting, searching, and subarray problems.",
                        prompt: "Show me practical applications of arrays in sorting algorithms, searching techniques, and solving subarray problems with real-world examples and code implementations."
                    }
                ]
            },
            "Strings": {
                description: "Sequence of characters with specialized algorithms for text processing and pattern matching.",
                subtopics: [
                    {
                        title: "String Operations",
                        description: "Basic string manipulation: concatenation, substring, reversal, comparison.",
                        prompt: "Teach me fundamental string operations including concatenation, substring extraction, string reversal, comparison methods, and their time complexities with code examples."
                    },
                    {
                        title: "Pattern Matching Algorithms",
                        description: "Advanced algorithms: Naive, KMP, Z-algorithm, Rabin-Karp for efficient pattern searching.",
                        prompt: "Explain pattern matching algorithms including Naive approach, KMP algorithm, Z-algorithm, and Rabin-Karp algorithm. Show me how each works, their time complexities, and when to use each with detailed examples."
                    },
                    {
                        title: "String Hashing",
                        description: "Using hash functions for fast string comparison and pattern matching.",
                        prompt: "Teach me string hashing techniques, including rolling hash, polynomial hashing, and how to use them for efficient string comparison and pattern matching with collision handling."
                    },
                    {
                        title: "Palindrome Problems",
                        description: "Algorithms for detecting and working with palindromic strings.",
                        prompt: "Explain palindrome detection algorithms, including methods to find longest palindromic substring, count palindromic substrings, and palindrome partitioning with dynamic programming approaches."
                    },
                    {
                        title: "Trie (Prefix Tree)",
                        description: "Tree data structure for efficient string storage and prefix-based operations.",
                        prompt: "Teach me about Trie data structure, including its implementation, operations (insert, search, delete), applications in autocomplete and word games, with code examples and complexity analysis."
                    },
                    {
                        title: "Suffix Arrays and Suffix Trees",
                        description: "Advanced data structures for efficient suffix-based string operations.",
                        prompt: "Explain suffix arrays and suffix trees, including their construction algorithms, applications in string matching and bioinformatics, with detailed explanations and implementation examples."
                    }
                ]
            },
            "Linked Lists": {
                description: "Dynamic data structure where elements are stored in nodes with pointers to the next element.",
                subtopics: [
                    {
                        title: "Types of Linked Lists",
                        description: "Singly, doubly, and circular linked lists with their characteristics.",
                        prompt: "Teach me about different types of linked lists: singly linked, doubly linked, and circular linked lists. Explain their structures, advantages, disadvantages, and when to use each type with implementation examples."
                    },
                    {
                        title: "Linked List Operations",
                        description: "Core operations: insertion, deletion, traversal, and reversal.",
                        prompt: "Explain all fundamental linked list operations including insertion at different positions, deletion of nodes, traversal methods, and list reversal algorithms with iterative and recursive approaches."
                    },
                    {
                        title: "Cycle Detection (Floyd's Algorithm)",
                        description: "Detecting and removing cycles in linked lists using Floyd's cycle detection.",
                        prompt: "Teach me Floyd's cycle detection algorithm for linked lists, including how to detect cycles, find the starting point of the cycle, and remove cycles with detailed explanations and code."
                    },
                    {
                        title: "Merging and Intersection",
                        description: "Algorithms for merging sorted lists and finding intersections.",
                        prompt: "Explain algorithms for merging two sorted linked lists and finding the intersection of two linked lists, including handling duplicates and maintaining sorted order with examples."
                    },
                    {
                        title: "Advanced Linked List Problems",
                        description: "Complex problems like reversing in groups, detecting loops, and palindrome detection.",
                        prompt: "Teach me advanced linked list problems including reversing in groups, detecting and removing loops, palindrome detection, and other complex manipulation problems with step-by-step solutions."
                    },
                    {
                        title: "Applications",
                        description: "Real-world applications in memory management, LRU cache, and undo operations.",
                        prompt: "Show me real-world applications of linked lists in memory management, LRU cache implementation, undo operations in text editors, and other practical use cases with implementation details."
                    }
                ]
            },
            "Stacks": {
                description: "LIFO (Last In, First Out) data structure for managing elements with push and pop operations.",
                subtopics: [
                    {
                        title: "Stack Operations",
                        description: "Basic operations: push, pop, peek, and isEmpty with their implementations.",
                        prompt: "Teach me about stack operations including push, pop, peek, and isEmpty operations. Explain their time complexities and show me implementations using both arrays and linked lists."
                    },
                    {
                        title: "Stack Implementation",
                        description: "Implementing stacks using arrays and linked lists with pros and cons.",
                        prompt: "Explain how to implement stacks using arrays and linked lists, including the advantages and disadvantages of each approach, with complete code examples and memory considerations."
                    },
                    {
                        title: "Expression Evaluation",
                        description: "Using stacks to evaluate infix, prefix, and postfix expressions.",
                        prompt: "Teach me how to use stacks for expression evaluation, including converting between infix, prefix, and postfix notations, and implementing calculators with proper operator precedence handling."
                    },
                    {
                        title: "Balanced Parentheses",
                        description: "Checking for balanced brackets, parentheses, and other delimiters using stacks.",
                        prompt: "Explain how to use stacks to check for balanced parentheses, brackets, and other delimiters in expressions, including handling different types of brackets and nested structures."
                    },
                    {
                        title: "Monotonic Stack",
                        description: "Specialized stack technique for solving next greater/lesser element problems.",
                        prompt: "Teach me about monotonic stacks, including how they work, when to use them, and how to solve problems like finding next greater element, next smaller element, and largest rectangle in histogram."
                    },
                    {
                        title: "Backtracking Applications",
                        description: "Using stacks for backtracking algorithms and undo operations.",
                        prompt: "Explain how stacks are used in backtracking algorithms, including solving problems like N-Queens, generating permutations, and implementing undo operations in applications."
                    }
                ]
            },
            "Queues": {
                description: "FIFO (First In, First Out) data structure for managing elements in order.",
                subtopics: [
                    {
                        title: "Queue Operations",
                        description: "Basic operations: enqueue, dequeue, front, rear, and isEmpty.",
                        prompt: "Teach me about queue operations including enqueue, dequeue, front, rear, and isEmpty operations. Explain their time complexities and show me implementations using arrays and linked lists."
                    },
                    {
                        title: "Circular Queues",
                        description: "Efficient queue implementation using circular arrays to avoid space wastage.",
                        prompt: "Explain circular queue implementation, including how it solves the space wastage problem in array-based queues, with detailed implementation and boundary condition handling."
                    },
                    {
                        title: "Double-ended Queues (Deque)",
                        description: "Queues that allow insertion and deletion from both ends.",
                        prompt: "Teach me about double-ended queues (deque), including their operations, implementation using arrays and linked lists, and applications in solving specific problems."
                    },
                    {
                        title: "Priority Queues",
                        description: "Queues where elements are served based on priority rather than arrival order.",
                        prompt: "Explain priority queues, including their implementation using heaps, operations like insert, extract-max/min, and applications in scheduling algorithms and Dijkstra's algorithm."
                    },
                    {
                        title: "Queue Applications",
                        description: "Applications in BFS traversal, scheduling, and sliding window problems.",
                        prompt: "Show me applications of queues in BFS graph traversal, CPU scheduling algorithms, handling requests in web servers, and solving sliding window problems with examples."
                    },
                    {
                        title: "Advanced Queue Problems",
                        description: "Complex problems like implementing queues using stacks and vice versa.",
                        prompt: "Teach me advanced queue problems including implementing queues using stacks, implementing stacks using queues, and other complex manipulation problems with step-by-step solutions."
                    }
                ]
            },
            "Trees": {
                description: "Hierarchical data structure with nodes connected by edges, forming a tree-like structure.",
                subtopics: [
                    {
                        title: "Binary Trees",
                        description: "Trees where each node has at most two children with basic operations.",
                        prompt: "Teach me about binary trees, including their structure, properties, basic operations like insertion, deletion, and searching, with implementation examples and complexity analysis."
                    },
                    {
                        title: "Binary Search Trees (BST)",
                        description: "Ordered binary trees where left child < parent < right child.",
                        prompt: "Explain binary search trees, including their properties, operations (insert, delete, search), balancing concepts, and how they maintain sorted order with examples."
                    },
                    {
                        title: "Tree Traversals",
                        description: "Methods to visit all nodes: inorder, preorder, postorder, and level order.",
                        prompt: "Teach me all tree traversal methods including inorder, preorder, postorder (recursive and iterative), and level order traversal with code examples and when to use each method."
                    },
                    {
                        title: "Balanced Trees",
                        description: "Self-balancing trees: AVL, Red-Black, Splay, and Treap trees.",
                        prompt: "Explain balanced tree structures including AVL trees, Red-Black trees, Splay trees, and Treaps. Show me how they maintain balance and their performance characteristics."
                    },
                    {
                        title: "Segment Trees",
                        description: "Tree structure for efficient range queries and updates.",
                        prompt: "Teach me about segment trees, including their construction, range query operations, point updates, range updates with lazy propagation, and applications in competitive programming."
                    },
                    {
                        title: "Fenwick Trees (Binary Indexed Trees)",
                        description: "Efficient data structure for prefix sums and range queries.",
                        prompt: "Explain Fenwick trees (Binary Indexed Trees), including their implementation, operations for prefix sums and range queries, and how they compare to segment trees with examples."
                    },
                    {
                        title: "Heaps",
                        description: "Complete binary trees with heap property: min-heap and max-heap.",
                        prompt: "Teach me about heaps including min-heap and max-heap properties, heap operations (insert, extract, heapify), heap sort algorithm, and applications in priority queues."
                    },
                    {
                        title: "Advanced Tree Algorithms",
                        description: "Heavy-Light Decomposition, Centroid Decomposition, and LCA algorithms.",
                        prompt: "Explain advanced tree algorithms including Heavy-Light Decomposition, Centroid Decomposition, Lowest Common Ancestor (LCA) with binary lifting, and their applications in competitive programming."
                    }
                ]
            },
            "Graphs": {
                description: "Non-linear data structure with vertices connected by edges, representing relationships.",
                subtopics: [
                    {
                        title: "Graph Representation",
                        description: "Different ways to represent graphs: adjacency list, adjacency matrix, and edge list.",
                        prompt: "Teach me about graph representation methods including adjacency list, adjacency matrix, and edge list. Explain the pros and cons of each method and when to use them with examples."
                    },
                    {
                        title: "Graph Traversal",
                        description: "Breadth-First Search (BFS) and Depth-First Search (DFS) algorithms.",
                        prompt: "Explain graph traversal algorithms including BFS and DFS, their implementations (recursive and iterative), applications, and how to choose between them for different problems."
                    },
                    {
                        title: "Shortest Path Algorithms",
                        description: "Finding shortest paths: Dijkstra, Bellman-Ford, and Floyd-Warshall algorithms.",
                        prompt: "Teach me shortest path algorithms including Dijkstra's algorithm, Bellman-Ford algorithm, and Floyd-Warshall algorithm. Explain when to use each and their time complexities with examples."
                    },
                    {
                        title: "Minimum Spanning Tree",
                        description: "Finding minimum cost spanning trees using Kruskal's and Prim's algorithms.",
                        prompt: "Explain minimum spanning tree algorithms including Kruskal's algorithm (using Union-Find) and Prim's algorithm. Show me their implementations and when to use each approach."
                    },
                    {
                        title: "Topological Sort",
                        description: "Linear ordering of vertices in directed acyclic graphs.",
                        prompt: "Teach me topological sorting, including Kahn's algorithm and DFS-based approach, with applications in task scheduling and dependency resolution with examples."
                    },
                    {
                        title: "Connected Components",
                        description: "Finding strongly connected components and articulation points.",
                        prompt: "Explain algorithms for finding connected components, strongly connected components using Kosaraju's and Tarjan's algorithms, and identifying articulation points and bridges."
                    },
                    {
                        title: "Network Flow",
                        description: "Maximum flow algorithms: Ford-Fulkerson, Edmonds-Karp, and Dinic's algorithm.",
                        prompt: "Teach me network flow algorithms including Ford-Fulkerson method, Edmonds-Karp algorithm, and Dinic's algorithm for finding maximum flow in networks with examples."
                    },
                    {
                        title: "Advanced Graph Algorithms",
                        description: "Eulerian/Hamiltonian paths, bipartite matching, and advanced shortest paths.",
                        prompt: "Explain advanced graph algorithms including Eulerian and Hamiltonian path detection, bipartite matching, A* algorithm, and Johnson's algorithm for all-pairs shortest paths."
                    }
                ]
            },
            "Hashing": {
                description: "Technique for mapping data to fixed-size values using hash functions for fast access.",
                subtopics: [
                    {
                        title: "Hash Tables",
                        description: "Data structure implementing associative arrays using hash functions.",
                        prompt: "Teach me about hash tables, including their structure, how they work, advantages over arrays and linked lists, and basic operations with implementation examples."
                    },
                    {
                        title: "Hash Functions",
                        description: "Functions that map data to fixed-size values with good distribution properties.",
                        prompt: "Explain hash functions, including properties of good hash functions, different types (division method, multiplication method), and how to design effective hash functions."
                    },
                    {
                        title: "Collision Resolution",
                        description: "Handling collisions: chaining, open addressing, and double hashing.",
                        prompt: "Teach me collision resolution techniques including separate chaining, linear probing, quadratic probing, and double hashing with their advantages and disadvantages."
                    },
                    {
                        title: "Applications",
                        description: "Using hashing for frequency counting, sets, maps, and caching.",
                        prompt: "Show me applications of hashing including frequency counting, implementing sets and maps, caching mechanisms, and database indexing with practical examples."
                    },
                    {
                        title: "String Hashing",
                        description: "Specialized hashing techniques for strings and text processing.",
                        prompt: "Explain string hashing techniques including polynomial hashing, rolling hash, and how to use them for efficient string comparison and pattern matching."
                    },
                    {
                        title: "Advanced Hashing",
                        description: "Consistent hashing, bloom filters, and cryptographic hash functions.",
                        prompt: "Teach me advanced hashing concepts including consistent hashing for distributed systems, bloom filters for membership testing, and cryptographic hash functions with applications."
                    }
                ]
            },
            "Heaps & Priority Queues": {
                description: "Complete binary trees with heap property for efficient priority-based operations.",
                subtopics: [
                    {
                        title: "Heap Properties",
                        description: "Min-heap and max-heap properties and their characteristics.",
                        prompt: "Teach me about heap properties including min-heap and max-heap, their characteristics, how they maintain the heap property, and visual representations with examples."
                    },
                    {
                        title: "Heap Operations",
                        description: "Core operations: insertion, deletion, heapify, and extract operations.",
                        prompt: "Explain heap operations including insert, delete, heapify (up and down), extract-min/max, and their time complexities with step-by-step implementations."
                    },
                    {
                        title: "Heap Sort",
                        description: "Sorting algorithm using heap data structure with O(n log n) complexity.",
                        prompt: "Teach me heap sort algorithm, including how it works, its implementation, time and space complexity analysis, and comparison with other sorting algorithms."
                    },
                    {
                        title: "Priority Queue Implementation",
                        description: "Implementing priority queues using heaps for efficient operations.",
                        prompt: "Explain how to implement priority queues using heaps, including operations like insert, extract-max/min, and applications in scheduling algorithms with examples."
                    },
                    {
                        title: "Advanced Heap Types",
                        description: "Binomial heaps, Fibonacci heaps, and other specialized heap structures.",
                        prompt: "Teach me about advanced heap types including binomial heaps, Fibonacci heaps, their operations, amortized analysis, and when to use them over binary heaps."
                    },
                    {
                        title: "Heap Applications",
                        description: "Applications in median maintenance, kth largest element, and merge k sorted lists.",
                        prompt: "Show me applications of heaps including finding median of running stream, kth largest element, merging k sorted lists, and other practical problems with solutions."
                    }
                ]
            },
            "Searching & Sorting": {
                description: "Fundamental algorithms for finding elements and arranging data in order.",
                subtopics: [
                    {
                        title: "Searching Algorithms",
                        description: "Linear search, binary search, and ternary search techniques.",
                        prompt: "Teach me searching algorithms including linear search, binary search (iterative and recursive), ternary search, and binary search on answer with examples and complexity analysis."
                    },
                    {
                        title: "Basic Sorting Algorithms",
                        description: "Bubble sort, selection sort, and insertion sort with their characteristics.",
                        prompt: "Explain basic sorting algorithms including bubble sort, selection sort, and insertion sort. Show me their implementations, time complexities, and when to use each with examples."
                    },
                    {
                        title: "Efficient Sorting Algorithms",
                        description: "Merge sort, quick sort, and heap sort with O(n log n) complexity.",
                        prompt: "Teach me efficient sorting algorithms including merge sort, quick sort, and heap sort. Explain their implementations, time complexities, and stability properties with examples."
                    },
                    {
                        title: "Specialized Sorting",
                        description: "Counting sort, radix sort, and bucket sort for specific data types.",
                        prompt: "Explain specialized sorting algorithms including counting sort, radix sort, and bucket sort. Show me when to use them and their time complexities with examples."
                    },
                    {
                        title: "Sorting Properties",
                        description: "Understanding stable vs unstable, in-place vs out-of-place sorting.",
                        prompt: "Teach me about sorting algorithm properties including stable vs unstable sorting, in-place vs out-of-place sorting, and how to analyze these properties with examples."
                    },
                    {
                        title: "Sorting Applications",
                        description: "Real-world applications and optimization techniques in sorting.",
                        prompt: "Show me real-world applications of sorting algorithms, optimization techniques, and how to choose the right sorting algorithm for different scenarios with practical examples."
                    }
                ]
            },
            "Recursion & Backtracking": {
                description: "Problem-solving techniques using function calls and systematic exploration of solutions.",
                subtopics: [
                    {
                        title: "Recursion Fundamentals",
                        description: "Understanding recursion, base cases, recursive cases, and call stack.",
                        prompt: "Teach me recursion fundamentals including how recursion works, base cases, recursive cases, call stack mechanism, and common recursion patterns with examples."
                    },
                    {
                        title: "Backtracking Algorithms",
                        description: "Systematic exploration of solution space with backtracking technique.",
                        prompt: "Explain backtracking algorithms including the general backtracking template, how to implement it, and common patterns with examples like generating permutations and combinations."
                    },
                    {
                        title: "Classic Backtracking Problems",
                        description: "N-Queens, Sudoku solver, and subset sum problems.",
                        prompt: "Teach me classic backtracking problems including N-Queens problem, Sudoku solver, subset sum problem, and how to optimize backtracking solutions with pruning techniques."
                    },
                    {
                        title: "Memoization",
                        description: "Top-down dynamic programming technique using memoization.",
                        prompt: "Explain memoization technique, including how it works, when to use it, implementation details, and how it differs from tabulation with examples."
                    },
                    {
                        title: "Advanced Backtracking",
                        description: "Complex problems like word search, combination sum, and path finding.",
                        prompt: "Teach me advanced backtracking problems including word search, combination sum variations, path finding in mazes, and other complex problems with optimization techniques."
                    },
                    {
                        title: "Recursion Optimization",
                        description: "Tail recursion, space optimization, and avoiding common pitfalls.",
                        prompt: "Explain recursion optimization techniques including tail recursion, space optimization, avoiding stack overflow, and common recursion pitfalls with solutions."
                    }
                ]
            },
            "Dynamic Programming": {
                description: "Optimization technique solving complex problems by breaking them into simpler subproblems.",
                subtopics: [
                    {
                        title: "DP Fundamentals",
                        description: "Overlapping subproblems, optimal substructure, and DP principles.",
                        prompt: "Teach me dynamic programming fundamentals including overlapping subproblems, optimal substructure property, and the core principles that make a problem suitable for DP with examples."
                    },
                    {
                        title: "DP Approaches",
                        description: "Top-down (memoization) vs bottom-up (tabulation) approaches.",
                        prompt: "Explain the two main DP approaches: top-down (memoization) and bottom-up (tabulation). Show me when to use each approach and how to convert between them with examples."
                    },
                    {
                        title: "Classic DP Problems",
                        description: "Knapsack, LIS, LCS, coin change, and matrix chain multiplication.",
                        prompt: "Teach me classic DP problems including 0/1 knapsack, longest increasing subsequence (LIS), longest common subsequence (LCS), coin change, and matrix chain multiplication with detailed solutions."
                    },
                    {
                        title: "DP on Trees",
                        description: "Applying dynamic programming to tree structures and tree problems.",
                        prompt: "Explain DP on trees including tree DP patterns, subtree DP, path DP, and how to solve tree problems using dynamic programming with examples."
                    },
                    {
                        title: "DP on Graphs",
                        description: "Using dynamic programming for graph problems and shortest paths.",
                        prompt: "Teach me DP on graphs including shortest path DP, graph coloring DP, and other graph problems that can be solved using dynamic programming techniques."
                    },
                    {
                        title: "Advanced DP Techniques",
                        description: "Digit DP, bitmask DP, and space optimization techniques.",
                        prompt: "Explain advanced DP techniques including digit DP, bitmask DP, state compression, and space optimization techniques with complex problem examples."
                    },
                    {
                        title: "DP Optimization",
                        description: "Monotonic queue optimization, divide and conquer DP, and convex hull trick.",
                        prompt: "Teach me DP optimization techniques including monotonic queue optimization, divide and conquer DP, convex hull trick, and other advanced optimization methods."
                    }
                ]
            },
            "Bit Manipulation": {
                description: "Techniques for manipulating individual bits in binary representations of data.",
                subtopics: [
                    {
                        title: "Bitwise Operators",
                        description: "AND, OR, XOR, NOT, and shift operators with their properties.",
                        prompt: "Teach me bitwise operators including AND (&), OR (|), XOR (^), NOT (~), left shift (<<), and right shift (>>) with their properties and truth tables."
                    },
                    {
                        title: "Bit Manipulation Tricks",
                        description: "Common bit manipulation techniques and useful bit patterns.",
                        prompt: "Explain common bit manipulation tricks including checking if a number is power of 2, counting set bits, finding the rightmost set bit, and other useful bit patterns."
                    },
                    {
                        title: "Bitmasking for Subsets",
                        description: "Using bitmasks to represent and manipulate subsets efficiently.",
                        prompt: "Teach me bitmasking for subsets including how to represent subsets using bitmasks, generating all subsets, and solving subset-related problems efficiently."
                    },
                    {
                        title: "Bitmask DP",
                        description: "Using bitmasks in dynamic programming for state representation.",
                        prompt: "Explain bitmask DP including how to use bitmasks to represent states in DP, solving problems like traveling salesman problem and other state-based DP problems."
                    },
                    {
                        title: "Bit Manipulation Applications",
                        description: "Applications in optimization, cryptography, and competitive programming.",
                        prompt: "Show me applications of bit manipulation in optimization problems, cryptography, competitive programming, and other real-world scenarios with examples."
                    },
                    {
                        title: "Advanced Bit Techniques",
                        description: "Bit manipulation in advanced algorithms and data structures.",
                        prompt: "Teach me advanced bit manipulation techniques including bit manipulation in segment trees, Fenwick trees, and other advanced data structures with examples."
                    }
                ]
            },
            "Number Theory": {
                description: "Mathematical algorithms and techniques for working with integers and number properties.",
                subtopics: [
                    {
                        title: "GCD and LCM",
                        description: "Greatest Common Divisor and Least Common Multiple using Euclidean algorithm.",
                        prompt: "Teach me about GCD and LCM including the Euclidean algorithm, extended Euclidean algorithm, and their applications in solving linear Diophantine equations with examples."
                    },
                    {
                        title: "Primality Testing",
                        description: "Algorithms for checking if a number is prime efficiently.",
                        prompt: "Explain primality testing algorithms including trial division, Fermat's test, Miller-Rabin test, and deterministic primality testing with complexity analysis."
                    },
                    {
                        title: "Sieve Algorithms",
                        description: "Sieve of Eratosthenes and other sieve techniques for finding primes.",
                        prompt: "Teach me sieve algorithms including Sieve of Eratosthenes, segmented sieve, and other sieve techniques for finding primes efficiently with examples."
                    },
                    {
                        title: "Prime Factorization",
                        description: "Algorithms for decomposing numbers into prime factors.",
                        prompt: "Explain prime factorization algorithms including trial division, Pollard's rho algorithm, and other methods for factoring large numbers with examples."
                    },
                    {
                        title: "Modular Arithmetic",
                        description: "Arithmetic operations under modular arithmetic with applications.",
                        prompt: "Teach me modular arithmetic including modular addition, subtraction, multiplication, division, modular exponentiation, and modular inverse with applications."
                    },
                    {
                        title: "Advanced Number Theory",
                        description: "Chinese Remainder Theorem, Fermat's Little Theorem, and Euler's Totient.",
                        prompt: "Explain advanced number theory concepts including Chinese Remainder Theorem, Fermat's Little Theorem, Euler's Totient function, and their applications in cryptography."
                    }
                ]
            },
            "Computational Geometry": {
                description: "Algorithms for solving geometric problems and working with geometric objects.",
                subtopics: [
                    {
                        title: "Convex Hull Algorithms",
                        description: "Graham scan, Jarvis march, and Andrew's monotone chain algorithms.",
                        prompt: "Teach me convex hull algorithms including Graham scan, Jarvis march (gift wrapping), and Andrew's monotone chain algorithm with their implementations and complexity analysis."
                    },
                    {
                        title: "Line Segment Intersection",
                        description: "Algorithms for finding intersections between line segments.",
                        prompt: "Explain line segment intersection algorithms including sweep line algorithm, how to detect intersections, and handle special cases with examples."
                    },
                    {
                        title: "Closest Pair of Points",
                        description: "Divide and conquer algorithm for finding the closest pair of points.",
                        prompt: "Teach me the closest pair of points algorithm using divide and conquer approach, including the algorithm, implementation, and complexity analysis."
                    },
                    {
                        title: "Geometric Properties",
                        description: "Calculating area, perimeter, and other properties of geometric shapes.",
                        prompt: "Explain how to calculate geometric properties including area and perimeter of polygons, point in polygon test, and other geometric calculations with examples."
                    },
                    {
                        title: "Sweep Line Algorithms",
                        description: "Using sweep line technique for geometric problems.",
                        prompt: "Teach me sweep line algorithms including the general technique, applications in geometric problems, and how to implement sweep line solutions."
                    },
                    {
                        title: "Geometric Applications",
                        description: "Applications in graphics, GIS, robotics, and computer vision.",
                        prompt: "Show me applications of computational geometry in computer graphics, GIS systems, robotics, computer vision, and other real-world scenarios with examples."
                    }
                ]
            },
            "Advanced Data Structures": {
                description: "Sophisticated data structures for specialized applications and optimization.",
                subtopics: [
                    {
                        title: "Segment Trees with Lazy Propagation",
                        description: "Advanced segment trees with lazy updates for range operations.",
                        prompt: "Teach me segment trees with lazy propagation including how lazy updates work, implementation details, and solving range update problems efficiently."
                    },
                    {
                        title: "Persistent Data Structures",
                        description: "Data structures that maintain multiple versions efficiently.",
                        prompt: "Explain persistent data structures including persistent segment trees, persistent arrays, and how to implement them with examples."
                    },
                    {
                        title: "Disjoint Set Union (Union-Find)",
                        description: "Data structure for managing disjoint sets with union and find operations.",
                        prompt: "Teach me Disjoint Set Union (Union-Find) including path compression, union by rank, and applications in Kruskal's algorithm and cycle detection."
                    },
                    {
                        title: "Advanced Tree Structures",
                        description: "Treap, Splay tree, and other self-balancing tree structures.",
                        prompt: "Explain advanced tree structures including Treap, Splay tree, and other self-balancing trees with their properties and applications."
                    },
                    {
                        title: "Suffix Trees and Arrays",
                        description: "Advanced string data structures for efficient string operations.",
                        prompt: "Teach me suffix trees and suffix arrays including their construction algorithms, applications in string matching, and how to use them efficiently."
                    },
                    {
                        title: "Range Query Data Structures",
                        description: "Specialized structures for efficient range queries and updates.",
                        prompt: "Explain range query data structures including Fenwick trees, segment trees, and other structures for handling range operations with examples."
                    }
                ]
            },
            "Advanced Graph Algorithms": {
                description: "Sophisticated graph algorithms for complex graph problems and optimization.",
                subtopics: [
                    {
                        title: "Network Flow Algorithms",
                        description: "Ford-Fulkerson, Edmonds-Karp, and Dinic's algorithms for maximum flow.",
                        prompt: "Teach me network flow algorithms including Ford-Fulkerson method, Edmonds-Karp algorithm, and Dinic's algorithm for finding maximum flow in networks."
                    },
                    {
                        title: "Minimum Cost Flow",
                        description: "Algorithms for finding minimum cost flows in networks.",
                        prompt: "Explain minimum cost flow algorithms including how to find flows with minimum cost, applications in optimization, and implementation details."
                    },
                    {
                        title: "Bipartite Matching",
                        description: "Algorithms for maximum matching in bipartite graphs.",
                        prompt: "Teach me bipartite matching algorithms including maximum bipartite matching, Hungarian algorithm, and applications in assignment problems."
                    },
                    {
                        title: "Advanced Shortest Paths",
                        description: "Johnson's algorithm, A* algorithm, and k-shortest paths.",
                        prompt: "Explain advanced shortest path algorithms including Johnson's algorithm for all-pairs shortest paths, A* algorithm, and finding k-shortest paths."
                    },
                    {
                        title: "Eulerian and Hamiltonian Paths",
                        description: "Algorithms for finding Eulerian and Hamiltonian paths and cycles.",
                        prompt: "Teach me algorithms for finding Eulerian paths and cycles, Hamiltonian paths and cycles, and their applications in graph theory."
                    },
                    {
                        title: "Graph Connectivity",
                        description: "Finding articulation points, bridges, and biconnected components.",
                        prompt: "Explain graph connectivity algorithms including finding articulation points, bridges, biconnected components, and strongly connected components."
                    }
                ]
            },
            "Advanced Tree Algorithms": {
                description: "Sophisticated algorithms for tree structures and tree-based problems.",
                subtopics: [
                    {
                        title: "Heavy-Light Decomposition",
                        description: "Technique for decomposing trees into chains for efficient queries.",
                        prompt: "Teach me Heavy-Light Decomposition including how it works, implementation details, and applications in solving path queries efficiently."
                    },
                    {
                        title: "Centroid Decomposition",
                        description: "Tree decomposition technique using centroids for divide and conquer.",
                        prompt: "Explain Centroid Decomposition including the concept of centroids, how to implement it, and applications in solving tree problems."
                    },
                    {
                        title: "Lowest Common Ancestor (LCA)",
                        description: "Algorithms for finding LCA using binary lifting and other techniques.",
                        prompt: "Teach me LCA algorithms including binary lifting technique, sparse table approach, and other methods for finding lowest common ancestors."
                    },
                    {
                        title: "Tree DP",
                        description: "Dynamic programming on trees for solving tree-based optimization problems.",
                        prompt: "Explain tree DP including common patterns, subtree DP, path DP, and how to solve optimization problems on trees using dynamic programming."
                    },
                    {
                        title: "Tree Queries",
                        description: "Handling various types of queries on tree structures efficiently.",
                        prompt: "Teach me tree query techniques including subtree queries, path queries, and how to handle different types of queries efficiently on trees."
                    },
                    {
                        title: "Advanced Tree Problems",
                        description: "Complex tree problems requiring advanced techniques and algorithms.",
                        prompt: "Show me advanced tree problems including complex tree manipulation, tree isomorphism, and other challenging tree-based problems with solutions."
                    }
                ]
            },
            "Advanced String Algorithms": {
                description: "Sophisticated algorithms for complex string processing and pattern matching.",
                subtopics: [
                    {
                        title: "Advanced Pattern Matching",
                        description: "KMP, Z-algorithm, and Rabin-Karp with optimizations and variations.",
                        prompt: "Teach me advanced pattern matching algorithms including optimized KMP, Z-algorithm variations, and Rabin-Karp with rolling hash optimizations."
                    },
                    {
                        title: "Suffix Arrays and Trees",
                        description: "Advanced string data structures for efficient string operations.",
                        prompt: "Explain suffix arrays and suffix trees including construction algorithms, applications in string matching, and how to use them for complex string problems."
                    },
                    {
                        title: "String Hashing Techniques",
                        description: "Advanced hashing techniques for strings and text processing.",
                        prompt: "Teach me advanced string hashing techniques including polynomial hashing, rolling hash, and applications in string comparison and pattern matching."
                    },
                    {
                        title: "Palindromic Tree (Eertree)",
                        description: "Specialized tree structure for palindrome-related problems.",
                        prompt: "Explain Palindromic Tree (Eertree) including its structure, operations, and applications in solving palindrome-related problems efficiently."
                    },
                    {
                        title: "String Compression",
                        description: "Algorithms for string compression and decompression.",
                        prompt: "Teach me string compression algorithms including Huffman coding, Lempel-Ziv compression, and other compression techniques with examples."
                    },
                    {
                        title: "Bioinformatics Applications",
                        description: "String algorithms in bioinformatics and DNA sequence analysis.",
                        prompt: "Show me applications of string algorithms in bioinformatics including DNA sequence alignment, pattern matching in genomes, and other biological applications."
                    }
                ]
            },
            "Probabilistic & Randomized Algorithms": {
                description: "Algorithms that use randomness to solve problems efficiently.",
                subtopics: [
                    {
                        title: "Monte Carlo Algorithms",
                        description: "Randomized algorithms that may produce incorrect results with known probability.",
                        prompt: "Teach me Monte Carlo algorithms including how they work, error probability analysis, and applications in primality testing and optimization."
                    },
                    {
                        title: "Las Vegas Algorithms",
                        description: "Randomized algorithms that always produce correct results but with random running time.",
                        prompt: "Explain Las Vegas algorithms including their properties, expected running time analysis, and applications in sorting and searching."
                    },
                    {
                        title: "Randomized Sorting",
                        description: "Randomized versions of sorting algorithms like randomized quicksort.",
                        prompt: "Teach me randomized sorting algorithms including randomized quicksort, its expected performance, and how randomization improves worst-case behavior."
                    },
                    {
                        title: "Randomized Primality Testing",
                        description: "Probabilistic methods for testing primality of large numbers.",
                        prompt: "Explain randomized primality testing including Miller-Rabin test, its error probability, and applications in cryptography."
                    },
                    {
                        title: "Randomized Data Structures",
                        description: "Data structures that use randomization for efficiency.",
                        prompt: "Teach me randomized data structures including skip lists, randomized binary search trees, and their expected performance characteristics."
                    },
                    {
                        title: "Applications in Cryptography",
                        description: "Using randomized algorithms in cryptographic applications.",
                        prompt: "Show me applications of randomized algorithms in cryptography including random number generation, cryptographic protocols, and security applications."
                    }
                ]
            },
            "Game Theory Algorithms": {
                description: "Algorithms for analyzing strategic decision-making in games and competitions.",
                subtopics: [
                    {
                        title: "Minimax Algorithm",
                        description: "Algorithm for finding optimal moves in two-player zero-sum games.",
                        prompt: "Teach me the minimax algorithm including how it works, implementation details, and applications in game AI and decision making."
                    },
                    {
                        title: "Alpha-Beta Pruning",
                        description: "Optimization technique for minimax algorithm to reduce search space.",
                        prompt: "Explain alpha-beta pruning including how it works, implementation details, and how it significantly improves the efficiency of minimax search."
                    },
                    {
                        title: "Grundy Numbers",
                        description: "Mathematical concept for analyzing impartial games and Nim games.",
                        prompt: "Teach me Grundy numbers including how to calculate them, applications in impartial games, and solving Nim game variations."
                    },
                    {
                        title: "Nim Game",
                        description: "Classic mathematical game and its variations with winning strategies.",
                        prompt: "Explain Nim game including the winning strategy, mathematical analysis, and variations like mis√®re Nim and other impartial games."
                    },
                    {
                        title: "Two-Player Games",
                        description: "Algorithms for analyzing various two-player games and finding optimal strategies.",
                        prompt: "Teach me algorithms for analyzing two-player games including tic-tac-toe, chess endgames, and other strategic games with optimal play."
                    },
                    {
                        title: "Applications in AI",
                        description: "Using game theory algorithms in artificial intelligence and machine learning.",
                        prompt: "Show me applications of game theory algorithms in AI including game playing agents, strategic decision making, and multi-agent systems."
                    }
                ]
            },
            "Miscellaneous & Patterns": {
                description: "Common algorithmic patterns and techniques used across different problem domains.",
                subtopics: [
                    {
                        title: "Two Pointer Technique",
                        description: "Efficient algorithm pattern using two pointers to solve array and string problems.",
                        prompt: "Teach me the two pointer technique including when to use it, common patterns, and how to apply it to solve array and string problems efficiently."
                    },
                    {
                        title: "Sliding Window Technique",
                        description: "Optimized approach for solving subarray and substring problems.",
                        prompt: "Explain the sliding window technique including fixed-size and variable-size windows, and how to apply it to solve subarray problems efficiently."
                    },
                    {
                        title: "Divide and Conquer",
                        description: "Problem-solving paradigm that breaks problems into smaller subproblems.",
                        prompt: "Teach me divide and conquer including the general approach, classic examples like merge sort and binary search, and when to use this technique."
                    },
                    {
                        title: "Greedy Algorithms",
                        description: "Algorithms that make locally optimal choices at each step.",
                        prompt: "Explain greedy algorithms including when they work, classic examples like activity selection and Huffman coding, and how to prove their correctness."
                    },
                    {
                        title: "Meet-in-the-Middle",
                        description: "Technique for reducing exponential time complexity by splitting problems.",
                        prompt: "Teach me meet-in-the-middle technique including how it works, applications in subset sum and other problems, and implementation details."
                    },
                    {
                        title: "Optimization Techniques",
                        description: "Space and time optimization tricks for improving algorithm efficiency.",
                        prompt: "Show me optimization techniques including space-time tradeoffs, memory optimization, and other tricks for improving algorithm efficiency."
                    },
                    {
                        title: "Problem-Solving Patterns",
                        description: "Common patterns like prefix sums, difference arrays, and monotonic structures.",
                        prompt: "Teach me common problem-solving patterns including prefix sums, difference arrays, monotonic stack/queue, and other recurring patterns in competitive programming."
                    }
                ]
            }
        };

        // Helper function to escape CSS selectors
        function escapeCSS(str) {
            return CSS.escape ? CSS.escape(str) : str.replace(/[^\w-]/g, '\\$&');
        }

        // Initialize the application
        function initializeApp() {
            createNavigationTabs();
            createTopicSections();
            setupSearchFunctionality();
            setupCopyFunctionality();
            showTopic('Arrays'); // Show first topic by default
        }

        // Create navigation tabs
        function createNavigationTabs() {
            const navTabs = document.getElementById('navTabs');
            if (!navTabs) return; // Safety check
            
            Object.keys(dsaData).forEach((topic, index) => {
                const tab = document.createElement('button');
                tab.className = 'nav-tab';
                tab.textContent = topic;
                tab.onclick = () => showTopic(topic);
                if (index === 0) tab.classList.add('active');
                navTabs.appendChild(tab);
            });
        }

        // Create topic sections
        function createTopicSections() {
            const topicSections = document.getElementById('topicSections');
            if (!topicSections) return; // Safety check
            
            Object.keys(dsaData).forEach(topic => {
                const section = document.createElement('div');
                section.className = 'topic-section';
                section.id = `topic-${topic}`;
                
                const data = dsaData[topic];
                section.innerHTML = `
                    <div class="topic-header">
                        <h2 class="topic-title">${topic}</h2>
                        <p class="topic-description">${data.description}</p>
                    </div>
                    <div class="subtopics-grid">
                        ${data.subtopics.map(subtopic => `
                            <div class="subtopic-card">
                                <h3 class="subtopic-title">${subtopic.title}</h3>
                                <p class="subtopic-description">${subtopic.description}</p>
                                <div class="prompt-box" onclick="copyToClipboard(this)">
                                    <button class="copy-btn">Copy</button>
                                    ${subtopic.prompt}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
                topicSections.appendChild(section);
            });
        }

        // Show specific topic
        function showTopic(topicName) {
            // Update active tab
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            const tabIndex = Object.keys(dsaData).indexOf(topicName);
            if (tabIndex !== -1) {
                const activeTab = document.querySelector(`.nav-tab:nth-child(${tabIndex + 1})`);
                if (activeTab) activeTab.classList.add('active');
            }

            // Show topic section
            document.querySelectorAll('.topic-section').forEach(section => {
                section.classList.remove('active');
            });
            const topicSection = document.getElementById(`topic-${topicName}`);
            if (topicSection) {
                topicSection.classList.add('active');
            }
        }

        // Setup search functionality
        function setupSearchFunctionality() {
            const searchBox = document.getElementById('searchBox');
            if (!searchBox) return; // Safety check
            
            searchBox.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase();
                
                if (searchTerm === '') {
                    // Clear search mode - remove inline styles and restore normal tab behavior
                    document.querySelectorAll('.topic-section').forEach(section => {
                        section.style.display = '';
                        section.classList.remove('search-visible');
                    });
                    document.querySelectorAll('.subtopic-card').forEach(card => {
                        card.style.display = '';
                    });
                    // Show the currently active topic
                    const activeTab = document.querySelector('.nav-tab.active');
                    if (activeTab) {
                        showTopic(activeTab.textContent);
                    }
                    return;
                }

                // Search mode - show all matching topics and subtopics
                Object.keys(dsaData).forEach(topic => {
                    const topicData = dsaData[topic];
                    const topicMatches = topic.toLowerCase().includes(searchTerm) || 
                                       topicData.description.toLowerCase().includes(searchTerm);
                    
                    let hasSubtopicMatch = false;
                    const topicId = `topic-${topic}`;
                    const topicSection = document.getElementById(topicId);
                    
                    if (!topicSection) return; // Safety check
                    
                    topicData.subtopics.forEach((subtopic, index) => {
                        const subtopicMatches = subtopic.title.toLowerCase().includes(searchTerm) ||
                                              subtopic.description.toLowerCase().includes(searchTerm) ||
                                              subtopic.prompt.toLowerCase().includes(searchTerm);
                        
                        // Use direct child selection instead of querySelector to avoid CSS escaping issues
                        const cards = topicSection.querySelectorAll('.subtopic-card');
                        const card = cards[index];
                        
                        if (card) {
                            card.style.display = subtopicMatches ? 'block' : 'none';
                            if (subtopicMatches) hasSubtopicMatch = true;
                        }
                    });

                    if (topicMatches || hasSubtopicMatch) {
                        topicSection.style.display = 'block';
                        topicSection.classList.add('active', 'search-visible');
                    } else {
                        topicSection.style.display = 'none';
                        topicSection.classList.remove('search-visible');
                    }
                });
            });
        }

        // Setup copy functionality
        function setupCopyFunctionality() {
            window.copyToClipboard = function(element) {
                const btn = element.querySelector('.copy-btn');
                if (!btn) return;
                
                const text = element.textContent.replace('Copy', '').trim();
                
                if (!navigator.clipboard) {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    textArea.style.position = 'fixed';
                    textArea.style.opacity = '0';
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        showCopySuccess(btn);
                    } catch (err) {
                        console.error('Copy failed:', err);
                    }
                    document.body.removeChild(textArea);
                    return;
                }
                
                navigator.clipboard.writeText(text).then(() => {
                    showCopySuccess(btn);
                }).catch(err => {
                    console.error('Copy failed:', err);
                });
            };
            
            function showCopySuccess(btn) {
                const originalText = btn.textContent;
                const originalBg = btn.style.background;
                btn.textContent = 'Copied!';
                btn.style.background = 'var(--success)';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = originalBg || '';
                }, 2000);
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
